## 大数据展示
### 学生大数据组件 + 数据源
- ==学生大数据页面在视图view的home.vue,效果图如下==
    [![pAWcLTS.png](https://s21.ax1x.com/2024/11/20/pAWcLTS.png)](https://imgse.com/i/pAWcLTS)
- ==布局基本页面==
  - 页面分为左右两大板块,右板块又分为上下两个板块,整体加了背景图片,板块的划分使用了==24栏布局组件layout==
  ```
    <template>
        <div id="home">
            <el-row :gutter="20" class="parent" v-if="isCreated">
                <!-- 左边 -->
                <el-col :span="12">
                    <!-- 父传子 -->
                    <classAverageEchart :data="{ studentsData, classData, tagsData }"></classAverageEchart>
                </el-col>
                <!-- 右边 -->
                <el-col :span="12">
                    <el-row :gutter="20" class="parent">
                        <!-- 撑满24,换行,上下布局 -->
                        <el-col :span="24" class="item">
                            <!-- 右上,全体学生平均值 -->
                            <AverageEchart :data="{ studentsData, tagsData }"></AverageEchart>
                        </el-col>
                        <el-col :span="24" class="item">
                            <!-- 右下,全体学生风险评估(倒数5名) -->
                            <DangerStudent :data="{ studentsData, tagsData }"></DangerStudent>
                        </el-col>
                    </el-row>
                </el-col>
            </el-row>
        </div>
    </template>
  ```
  - ==24栏组件el-row:==
    - 左/右: 行提供 gutter 属性来指定列之间的间距，其默认值为0,这里左右平分(12-12)页面,中间间隔20px
    - 右的(上/下): 撑满24,换行,上下布局
    - ==**属性v-if="isCreated"**==: 大数据页面的图标都是来自echart组件,这些图标的数据源均来自学生大数据页面的axios获取,如果异步axios获取时间超时,导致echart在没有获取到数据的前提下进行渲染图标,会造成bug,所以我们需要等待所有数据获取成功后,再创建(v-if通过)tem相关解构,此时组件再获取数据就绝对安全了!
    ```
        const studentsData = ref([])
        const classData = ref([])
        const tagsData = ref([])

        const isCreated = ref(false) // 控制创建echarts的属性
        onMounted(async () => {
            // 函数本身的异步不会影响外面的同步执行,所以外面也要异步
            await getStudentList()
            await getClassList()
            await getTagList()
            isCreated.value = true
        })

        const getStudentList = async () => {
            studentsData.value = await axios.get("/adminapi/students")
        }
        const getClassList = async () => {
            classData.value = await axios.get("/adminapi/classes")
        }
        const getTagList = async () => {
            tagsData.value = await axios.get("/adminapi/tags")
        }
    ```
    > onMounted也被加上了async-await,确保了数据都请求到后,再isCreated.value = true
- 对布局样式设置了宽高等css基本样式:
  ```
    <style lang="scss" scoped>
        // 大小适配图片
        .parent {
            height: 84vh;

            .item {
                height: 50%;
            }
        }

        // 加背景
        #home {
            background: url("../../assets/bg.png") no-repeat center;
            background-size: 100% 100%;
            padding: 10px;
            color: white;
        }
    </style>
  ```
### 学生大数据-各班级均值
- 构建学生大数据页面(1): ==**左侧页面的内容**,由组件classAverageEchart负责完成(components/home/classAverageEchart.vue)==
  ```
    <!-- 左边 -->
    <el-col :span="12">
        <!-- 父传子 -->
        <classAverageEchart :data="{ studentsData, classData, tagsData }"></classAverageEchart>
    </el-col>
  ```
  > 父传子数据: ==所有学生的信息;班级的信息;标签的信息==
- ==classAverageEchart.vue==
  - echart组件--数据集的一个饼状图+折线图的demo
    ```
    <template>
        <!-- 为 ECharts 准备一个定义了id和宽高的 DOM,用于装载echarts的内容 -->
        <div id="classAverageEchart">
            classAverageEchart
        </div>
    </template>

    <script setup>
        import { onMounted } from 'vue'
        // 1.导入echarts
        import * as echarts from 'echarts';

        // 接受父信息
        const props = defineProps(["data"])

        // 2.这里不必nextTick,在父组件当所有的数据都创建完了,才创建出来的,创建代码在onMounted()函数的最后一步,等待所有的工作做完才创建的el-row,里面是咱们的组件
        onMounted(() => {
            // 基于准备好的dom，初始化echarts实例
            var myChart = echarts.init(document.getElementById('classAverageEchart'));
            // 数据处理函数 
            let { source, series } = handleDate(props.data)

            // 配置参数(来自'示例/数据集')
            var option = {
                title: [
                    {   // 饼状图标题设置,位置自适应,如果位置出错记得刷新一下
                        text: "各班级技术Tag平均值",
                        textStyle: {
                            fontSize: 14,
                            color: "white"
                        }

                    }
                ],
                legend: { // 改上面图例的样式
                    textStyle: {
                        fontSize: 14,
                        color: "white"
                    }
                },
                tooltip: {
                    trigger: 'axis',
                    showContent: false
                },
                dataset: {
                    // source: [ // 第一个数据: X轴; 后面的数据是所有种类及其Y轴
                    //     // 第一个应该是tags的13个技术标签(静态遍历创建); 后面的种类应该是2001 2002 2003班及当科的全班平均分(动态创建,可更新)
                    //     ['product', '2012', '2013', '2014', '2015', '2016', '2017'],
                    //     ['Milk Tea', 56.5, 82.1, 88.7, 70.1, 53.4, 85.1],
                    //     ['Matcha Latte', 51.1, 51.4, 55.1, 53.3, 73.8, 68.7],
                    //     ['Cheese Cocoa', 40.1, 62.2, 69.5, 36.4, 45.2, 32.5],
                    //     ['Walnut Brownie', 25.2, 37.1, 41.2, 18, 33.9, 49.1]
                    // ]
                    source // 简写
                },
                // 控制x轴显示,让所有的x轴Tags都显示
                xAxis: {
                    type: 'category',
                    axisLabel: { // x轴标签
                        interval: 0, //间隔
                        rotate: 50 // 旋转50度
                    },
                    axisLine: { // x轴的样式
                        lineStyle: {
                            color: "white"
                        }
                    }
                },
                yAxis: {
                    gridIndex: 0,
                    max: 5,
                    axisLine: { // y轴的样式
                        lineStyle: {
                            color: "white"
                        }
                    }
                },
                grid: { top: '55%' },
                series // 简写,饼状图的初始配置
            };
            // pie饼状图附带监听事件,鼠标移动在折线图上查看数据移动时触发
            myChart.on('updateAxisPointer', function (event) {
                const xAxisInfo = event.axesInfo[0];
                if (xAxisInfo) {
                    const dimension = xAxisInfo.value + 1;
                    myChart.setOption({
                        series: {
                            id: 'pie',
                            label: {  // 之后饼图的动态显示 
                                formatter: '{b}班: {@[' + dimension + ']}分'
                            },
                            encode: {
                                value: dimension,
                                tooltip: dimension
                            }
                        }
                    });
                }
            });

            // 使用刚指定的配置项和数据显示图表。
            myChart.setOption(option);

            })
    </script>
    ```
    > ==内部出多数据的配置都可以查询文档解决,主要了解其意思,才能替换其对应数据==
- ==组件的属性介绍及数据整理==
  - title: 大标题,可设置样式
  - legend: 图例,可更改样式
  - ==dataset: 折线图的数据源,数组内的第一个item是X轴,后面的item是种类及其值,与X轴一一对应==
  - xAxis: X轴的样式
  - yAxis: Y轴的样式
  - series: 饼状图配置
    - label: 初始化显示配置/ formatter: 饼状图索引数据 
    - encode: 初始化的x轴坐标/ itemName: X轴名字(dataset的第一个item数据起的名字) value+tooltip: X轴起点的坐标名
  - myChart.on(): 饼状图的监听函数
    - label: 饼状图在初始化后,之后鼠标移动到不同X轴坐标显示不同的饼状图样式,这里配置动态显示的饼状图索引数据(与初始化中的label一个作用)
- 配图:(==绿色圈内的为图例---legend,红色圈内的为饼状图索引数据---series/formatter和动态配置myChart.on()/label==)
  [![pAWcLTS.png](https://s21.ax1x.com/2024/11/20/pAWcLTS.png)](https://imgse.com/i/pAWcLTS)
- **配置数据函数handleDate,主要配置dataset的source数据,其次是series**
- ==1.配置source数据:(**前提获取了父信息**==)
  ```
    // 接受父信息
    const props = defineProps(["data"])

    onMounted(()=>{
        ....
        let { source, series } = handleDate(props.data)
        ....
    })

    const handleDate = ({ studentsData, classData, tagsData }) => {
        const source = []
        const series = []
        // console.log(tagsData)

        // source第一个数据: 科目的遍历 X轴
        source.push([
            "tags", // 随影起名字
            // 展开运算,tag数组映射出里面的科目title
            ...tagsData.data.map(item => item.title)
        ])
        // console.log(source) 

        // source后面的数据: 班级+班级每科平均分
        classData.data.forEach(item => { // 遍历classData,即遍历出几个班级(几条折线数据)
            // getAverage返回为数字类型,记得展开合并
            var arr = [item.title, ...getAverage(studentsData, tagsData, item._id)]
            source.push(arr)
            series.push({
                type: 'line',
                smooth: true,
                seriesLayoutBy: 'row',
                emphasis: { focus: 'series' }
            })
        })

        .....
    }
  ```
  - ==优先配置第一个item数据==: 由X轴名字和13个科目标签组成,结构为`["tags","html5","css3","DOM操作",....]`,如代码,通过push操作,tags+tagsData的map映射,简单解决(title就是科目名)
  - 后面的数据: ==我们要3个班级的折线情况,所以遍历班级2001 2002 2003,**结构为`[班级名,全班各科目平均成绩依次排列]`,最终呈现效果如下图**==
    [![pAWBTsO.png](https://s21.ax1x.com/2024/11/20/pAWBTsO.png)](https://imgse.com/i/pAWBTsO)
  - ==全班各科平均成绩我们**用函数getAverage负责整理**==,最后传递一个纯数字数组,再借助展开运算符即可解决,向函数传递参数studentsData, tagsData, item._id(==其中第三个为此班级的ObjectId==)
- 函数getAverage(==修改和复用之前的函数,student-manage/StudentChart.vue的handleData内部部分函数==)
  ```
    const getAverage = (studentsData, tagsData, classId) => {
        const currentClass = studentsData.data.filter(item => item.class._id === classId)

        const average = []

        tagsData.data.forEach(({ title }, index) => {
            let filterArr = currentClass.filter(item => item.score[title])
            average[index] = (filterArr.map(item => item.score[title]).reduce((total, item) => total + item, 0) / (filterArr.length || 1)).toFixed(2)
        })

        return average
    }
  ```
  > 几乎没有任何变化,就改了一个地方,即第一行代码,我们通过传递的班级ObjectId从全部学生中筛选出此班级的学生,然后对此班级的学生进行各科平均分计算,==注意别忘了,此科目没有评分的学生不在"此科目全班平均分计算"范畴内==
- ==2.配置初始化饼图series和后续监控饼图函数==
  ```
    // 紧接上面handleData函数的source处理部分

    // 最后记得饼状图,属性可以通过官方查文档了解
    series.push({
        type: 'pie',
        id: 'pie',
        radius: '30%',
        center: ['50%', '25%'],
        emphasis: {
            focus: 'self'
        },
        label: { // 初始化显示
            formatter: '{b}班: {@html5}分', // 控制饼状图显示
            // {b}: 占位符,将来拿种类名,2001 2002 2003
            // {@2012}: 默认显示x轴,我们默认显示html5一列的数据
            color: "#fff" // 字体颜色
        },
        encode: {
            // x轴的起点,当时我们起名字tags
            itemName: 'tags',
            value: 'html5',
            tooltip: 'html5'
        }
    })

    // 最后返回整理好的两个数据
    return {
        source,
        series
    }
  ```
  > ==看注释,简单的初始化,结合上面的组件属性介绍==
- 动态监控饼状图索引提示,就改了一个地方,==注释处formatter==
  ```
    // pie饼状图附带监听事件,鼠标移动在折线图上查看数据移动时触发
    myChart.on('updateAxisPointer', function (event) {
        const xAxisInfo = event.axesInfo[0];
        if (xAxisInfo) {
            const dimension = xAxisInfo.value + 1;
            myChart.setOption({
                series: {
                    id: 'pie',
                    label: {  // 之后饼图的动态显示索引 
                        formatter: '{b}班: {@[' + dimension + ']}分'
                    },
                    encode: {
                        value: dimension,
                        tooltip: dimension
                    }
                }
            });
        }
    });
  ```
### 学生大数据-技术强弱图
- 学生大数据(2): ==**页面的右上部分内容**,由AverageEchart组件负责(components/home/AverageEchart.vue)==
- 此组件作用是显示全体学生成绩平均值,所以父传子的信息不再传递班级数据
  ```
    <el-col :span="24" class="item">
        <!-- 右上,全体学生平均值 -->
        <AverageEchart :data="{ studentsData, tagsData }"></AverageEchart>
    </el-col>
  ```
- AverageEchart.vue(==样例来自'示例/柱状图/极坐标柱状图',不同的echart图标样例只需要不同option参数配置==)
- 接受父信息,配置基础的echarts等操作略去,只关注option参数的变化和数据整理,其中重复的属性一笔带过
  ```
    // 配置参数(来自'示例/柱状图/极坐标柱状图')
    var option = {
        title: [ // 标题
            {
                text: '全体学生技术Tag强弱图',
                textStyle: {
                    fontSize: 14,
                    color: "#fff"
                }
            }
        ],
        polar: {
            radius: [30, '80%']
        },
        radiusAxis: { // 角度轴y轴最大值 =5
            max: 5,
            axisLine: { // y轴颜色
                lineStyle: {
                    color: "#fff"
                }
            }
        },
        angleAxis: { // angle意为'四周',角度轴
            type: 'category',
            // data: ['a', 'b', 'c', 'd'], // 未来是Tags学科名字,角度轴数据
            data: angleAxisData,
            startAngle: 75,
            axisLine: { // 角度轴颜色
                lineStyle: {
                    color: "#fff"
                }
            }
        },
        tooltip: {},
        series: {
            type: 'bar',
            // data: [2, 1.2, 2.4, 3.6], // 对应学科全部学生的平均值
            data: seriesData,
            coordinateSystem: 'polar',
            label: {
                show: true,
                position: 'middle',
                // formatter: '{b}: {c}' 
                formatter: '' // 不显示每一条柱状的名称,显示不开
            }
        },
        colorBy:"data", // 和之前不同,这里的数据共属于一条,即全部学生,而非2001 2002 2003的区分,所以要添加新属性,每一个数据独有一个颜色
        // 调色盘,提供更多的颜色
        color: ['#FCCE10', '#E87C25', '#9BCA63', '#FAD860', '#F3A43B', '#60C0DD', '#D7504B', '#C6E579', '#F4E001', '#F0805A', '#26C0C0'],
        animation: true // 有动画
    };
  ```
  - title: 标题
  - angleAxis: 相当于X轴,这里是角度轴,360度环绕
    - data: 角度轴数据, `[13个学科名]`
  - radiusAxis: 等于Y轴
  - series: 
    - ==data: Y轴的值==
    - label/formatter: 每条柱显示的信息,如果不希望有,请赋空值"",别不写,有默认的
  - color + colorBy: 前者是调色板,后者是为了让每根柱都有不同的颜色
   关于colorBy的注意事项:和之前不同,这里的数据共属于一条,即全部学生,而非2001 2002 2003的区分,所以要添加新属性,每一个数据独有一个颜色
- ==数据整理函数handleDate:==
  ```
    const handleDate = ({ studentsData, tagsData }) => {
        return {
            angleAxisData: tagsData.data.map(item => item.title), // 角度轴,标签科目映射
            seriesData: getAverage(studentsData, tagsData)
        }
    }
  ```
  - 角度周(X轴)的标签获取: tagsData的map映射,十分简单,过
  - 全体学生的单科平均分: 依旧依据函数getAverage获取
  ```
    const getAverage = (studentsData, tagsData) => {
        const average = []

        tagsData.data.forEach(({ title }, index) => {
            let filterArr = studentsData.data.filter(item => item.score[title]) // 过滤所有学生有这个成绩的
            average[index] = (filterArr.map(item => item.score[title]).reduce((total, item) => total + item, 0) / (filterArr.length || 1)).toFixed(2)
        })

        return average
    }
  ```
  > 更加简单,不用再根据班级筛选学生了,直接对全体学生进行学科成绩筛选,遍历tagsData获取每个学科item,以此对所有学生的本学科成绩进行筛选,此目的是剔除掉本学科没有成绩的学生,所以一轮筛选后,数组内是本学科全体同学(有分数的)的大集合,然后进行reduce累加,然后除人数(数组长度),算平均(保留2为小数).
- ==最后把对应的数据放入柱状图options参数配置的对应位置,完善X和Y轴的数据显示,完活==
### 学生大数据-风险学生
- 学生大数据(3): ==**右下,学生风险评估部分**,由DangerStudent组件负责(components/home/DangerStudent.vue)==
- ==**组件功能介绍**==: 本内容负责在全体学生中,选取总成绩最低的5人,然后列出每个人成绩最低的5科(最多5科),最后增加点击跳转功能,即点击学生,跳转到学生列表页面,自动搜索出此学生的全部信息
- ==本次父传子和右上的AverageEchart组件一摸一样,只传递学生信息和标签信息,所以这里略掉相关代码==
- 学生列表页面:
  [![pARbNkR.png](https://s21.ax1x.com/2024/11/18/pARbNkR.png)](https://imgse.com/i/pARbNkR)
- DangerStudent.vue
  ```
    <template>
        <!-- el-table表格组件,加了点样式,保证el-table不溢出又有合理间距 -->
        <el-table id="DangerStudent" :data="tableData" style="width: 100%; height: 90%; margin-top: 5%;" class="table">
            <el-table-column label="风险学生">
                <template #default="scope">
                    <!-- 给学生名字添加新组件,el-link,新增跳转功能,跳转到学生列表,并把当前学生的信息搜索出来 -->
                    <!-- el-link 支持style属性,直接css定义颜色 -->
                    <el-link style="color: white;" @click="handleClick(scope.row.studentname)">{{ scope.row.studentname }}</el-link>
                </template>
            </el-table-column>

            <el-table-column label="班级">
                <template #default="scope">
                    {{ scope.row.class.title }}
                </template>
            </el-table-column>

            <el-table-column label="低tag值技术">
                <template #default="scope">
                    <!-- 不要以数组的形式显示,用' | '的形式连接在一起 -->
                    {{ scope.row.lowTag.join(" | ") }}
                </template>
            </el-table-column>
        </el-table>
    </template>
  ```
  - 这个部分不再是echarts的图标结构,而是列表el-table,分为三列,学生名字,学生班级(studentData中有此学生的班级信息),最低的5科成绩,==其中前面2个直接获取即可,看上面代码,而最后一个需要数据整理,由handleData函数负责==
- handleData函数: (已经接受父信息的两个参数了)
  ```
    const handleData = ({ studentsData, tagsData }) => {
        const averageStudent = []
        studentsData.data.forEach((item, index) => {
            let values = Object.values(item.score) // 只把此学生数据中的score属性拿出来,没有测评的科目不会被记入
            // 总成绩/学科数量(保留2位小数)
            let averageValue = (values.reduce((total, item) => total + item, 0) / values.length).toFixed(2)
            // 如果此学生所有科目都没有打分,这个values.length长度是0,结果为NaN(除0),这种学生属于还未测评的学生,不属于我们考虑范畴内,需要过滤
            // console.log(item,averageValue)

            if (!isNaN(averageValue)) { // 意思是如果这个学生是NaN的情况,即所有科目都还未测评的,则筛出去,不添加进最终数组
                averageStudent.push({
                    ...item, // 学生的所有数据
                    averageValue // 学生已有科目的平均分
                })
            }
        })

        // 对筛选后学生的平均分averageValue把所有对象进行排序
        averageStudent.sort((item1, item2) => item1.averageValue - item2.averageValue) // averageValue(个人成绩平均分)的大小排序
        // console.log(averageStudent)

        // 截取前5名,即平均分倒数5名的学生信息
        let students = averageStudent.slice(0, 5)
        let finalStudents = [] // 最终学生数据
        // 获取这5名学生数据低Tag值
        students.forEach((item, index) => {
            // 对每位学生的成绩进行枚举,转化为对应的二维数组
            // Object.entries()方法是 JavaScript 中用于将一个对象自身可枚举的属性[key, value]对转换为一个二维数组的方法。其中，每个子数组包含两个元素：第一个元素是属性名（键），第二个元素是属性值。
            let lowTag = Object.entries(item.score).sort((item1, item2) => item1[1] - item2[1]).slice(0, 5).map(item => item[0]) // 排序是对数组的第二项(即array[1])学生学科成绩进行排序,再截取前5项(最低的5项),有几个截取几个,最后我们映射这些数组的第一项[0],我们要的是其学科名
            // console.log(lowTag)
            finalStudents.push({
                ...item,
                lowTag
            })
        })
        // console.log(finalStudents) // 最后5名倒数学生数据和其最差的5们学科信息lowTag

        return finalStudents
    }
  ```
- ==第一步studentsData.data.forEach()遍历每个学生==
  - 通过Object.values(item.score),把此学生数据中的score属性拿出来,没有测评的科目不会被记入
  - ==然后进行平均分计算,并且没有规避NaN的情况==
  - ==if (!isNaN(averageValue))二次筛选:== 如果此学生所有科目都没有打分,这个values.length长度是0,结果为NaN(除0),这种学生属于还未测评的学生,不属于我们考虑范畴内,需要过滤,所以在评分未完成的情况下,经过本次筛选后,合格学生的数量只会小于等于学生总数
  - 然后对二次筛选的学生数据进行排序sort,依据averageValue(这是对象中的一个属性,意为个人成绩平均分)的大小排序
  - ==到此时数据效果图为:==
    [![pAWBbee.png](https://s21.ax1x.com/2024/11/20/pAWBbee.png)](https://imgse.com/i/pAWBbee)
  - 经过排序(正序,从小到大),截取前5个数据,即倒数5名的学生,放入新数组
  `let students = averageStudent.slice(0, 5)`
  - ==获取这5名学生数据低Tag值,students.forEach((item, index))=>{}==
  - 枚举每位学生,使用**Object.entries**对学生的score属性进行处理(==Object.entries()方法是 JavaScript 中用于将一个对象自身可枚举的属性[key, value]对转换为一个二维数组的方法。其中，每个子数组包含两个元素：第一个元素是属性名（键），第二个元素是属性值。==)
  [![pAWB7LD.png](https://s21.ax1x.com/2024/11/20/pAWB7LD.png)](https://imgse.com/i/pAWB7LD)
  - 然后经过排序sort,截取前5个数据slice,映射出学科名map之后,得出此学生最低的5科成绩,效果图如下
  [![pAWBoQK.png](https://s21.ax1x.com/2024/11/20/pAWBoQK.png)](https://imgse.com/i/pAWBoQK)
- 返回出数据后,最后在外面的el-table中,涉及数组,我们借助join()转化下格式显示即可
> 
- ==2.点击对应姓名即可跳转到学生列表页面并搜索的功能==
  - 新组件el-link,跳转链接的组件,配置点击事件函数,使用路由功能跳转
    ```
        <el-table-column label="风险学生">
            <template #default="scope">
                <!-- 给学生名字添加新组件,el-link,新增跳转功能,跳转到学生列表,并把当前学生的信息搜索出来 -->
                <!-- el-link 支持style属性,直接css定义颜色 -->
                <el-link style="color: white;" @click="handleClick(scope.row.studentname)">{{ scope.row.studentname }}</el-link>
            </template>
        </el-table-column>

        import {useRouter} from 'vue-router'

        // 记得引入useRouter
        const router = useRouter()
        // 点击学生名字跳转事件处理函数
        const handleClick = (name)=>{
            // console.log(name)
            // view跳转到studentlist路由,忘了path去router文件夹的config.js看
            // 传递参数,使用query方式(vue基础讲push跳转时讲过,如何携带参数及如何获取参数),不能使用${},这样浏览器会把name当作路由路径的一部分,最后就是404
            router.push(`/student-manage/studentlist?name=${name}`)
        }
    ```
    > ==看注释,这里由vue的基础知识,关于路由的跳转router.push的多种方法,这里为了携带信息,使用query方法==
- StudentList.vue: 学生列表组件
  ```
    <el-table-column>
            <!-- table自定义表头 -->
            <template #header>
                <!-- 双向绑定的数据记录你输入的值 -->
                <el-input v-model="search" size="small" placeholder="请输入学生的名字" />
            </template>
            <template #default="scope">
                {{ scope.row.studentname }}
            </template>
    </el-table-column>


    js:
    import {useRoute} from 'vue-router'
    // 获取当前路由的path,进而获取其内部的query.name,用于接收path中query传参的name属性
    const route = useRoute()
    const search = ref(route.query.name || "") // 搜索学生框的双向绑定,如果有相关信息就直接搜索,如果没有就默认空字符串
  ```
  > 对搜索的双向绑定初始化时进行更改,如果由传过来的query信息,就直接搜索,没有就默认空
- ==最后,关于组件DangerStudent的css样式问题,又涉及组件深度样式添加的(:deep),另外注意css的优先级,直接设置为最高的!important==
  ```
    <style scoped lang="scss">
        .table {
            background: url('../../assets/t_bg.png') no-repeat center;
            background-size: 100% 100%;

            // 原本el-table就有背景样式,记得这里给组件内部的标签加css样式需要深度选择 :deep()
            // 加上层级,级别最高(!important),所有的css样式都听我的
            :deep(tr) {
                background-color: rgba($color: #fff, $alpha: 0) !important; // 背景透明,alpha为透明度(0-1),这是完全透明的白色,注意: 纯 CSS 中通常没有$符号来定义参数,这里是scss下的写法,正常写在rgba的第四个参数, 纯css: rgba(255,255,255,0)
                color: white
            }

            :deep(th) {
                background-color: rgba($color: #fff, $alpha: 0) !important;
                color: white
            }

            :deep(tr):hover td {
                background-color: rgba($color: #fff, $alpha: 0) !important;
            }
        }
    </style>
  ```
### 面试管理全系列
- ==**我们一口气通关了,内部包含'公司列表组件,更新题库功能,面试题预览功能'三个部分**==
- interview-manage/CompanyList.vue,上传excel文件,根据上传文件的数据构成下列表格,==上传文件组件upload,复用添加班级页面的代码==
  ```
    tem: 
    <el-upload :auto-upload="false" :on-change="handleChange" style="width: 100%" v-model:file-list="fileList">
        <el-button class="ml-3" type="primary">
            选择就业excel文件
        </el-button>
    </el-upload>

    <!-- 公司的列表el-table + 搜索功能 (复制student-manage/studentList.vue) -->
    <el-table :data="computedTableData" style="width: 100%">
        <el-table-column>
            <!-- table自定义表头 -->
            <template #header>
                <!-- 双向绑定的数据记录你输入的值 -->
                <el-input v-model="search" size="small" placeholder="请输入公司的名字" />
            </template>
            <template #default="scope">
                {{ scope.row.title }}
            </template>
        </el-table-column>

        <el-table-column align="left" label="操作">
            <template #default="scope">
                <!-- 调整下高度,调整某一个的行高,这一行的行高都会跟着变化 -->
                <div style="display: flex; align-items: center; height: 55px;">
                    <el-button round type="primary" @click="handlePreview(scope.row)">面试题</el-button>
                    <el-button round type="warning" @click="handleUpdate(scope.row)">更新题库</el-button>
                </div>
            </template>
        </el-table-column>

        <!-- 占位,没内容 -->
        <el-table-column />
    </el-table>

    js:
    import ImportExcel from '../../util/ImportExcel'
    import axios from 'axios'

    const fileList = ref([])
    // 监听excel上传文件的函数
    const handleChange = (ev) => {
        console.log(ev.raw)
        ImportExcel(ev.raw, async (data) => {
            console.log(data) // 获取解析文件的信息,数组类型
            // 1.存储公司数据
            // 2.存储就业学生数据,这个数据和学生列表数据库是2个不同的数据集合,一个是就业学生数据,一个是测评成绩(正在学习的学生数据)
            // 接下来去后端完善这两个数据库模型的创建等操作

            // 发送公司数据 list是从data提取的公司信息
            const list = data.map(item => ({ title: item.company })) //公司名数组集合
            // console.log(list)
            await axios.post("/adminapi/companys", list)
            // 发送学生数据 data是完整的excel提取信息,也就是学生就业信息
            await axios.post("/adminapi/companystudents", data)

            getList() // 最后获取公司和学生的数据,根据这些数据进行页面的渲染

            // 延时1s清空上传列表
            setTimeout(() => {
                fileList.value = []
            }, 1000)
        })
    }


    // el-table公司表格数据源
    const tableData = ref([])
    const search = ref("")
    const getList = async () => {
        var { data } = await axios.get("/adminapi/companys") // 获取公司数据
        tableData.value = data
        // console.log(tableData.value)
    }

    // 计算属性计算table数据,然后把过滤的属性放在table表中,箭头函数后面就一句话,默认返回
    const computedTableData = computed(() => tableData.value.filter(
        // 筛选条件: 因为全是中文所以不在乎大小写匹配,计算属性返回过滤好的新数据
        data => data.title.includes(search.value)
    ))

    onMounted(() => {
        getList()
    })
        
  ```
- ==**步骤及思路:**==
  - 1.利用提前写好的ImportExcel组件获取excel文件的数据,然后数据整理为公司名数据list发送新的公司路由地址,再发送原数据给新的学生就业路由地址
  - 2.构建后端,新建2个模型,分别为公司数据和就业学生数据,然后把整理的数据存进去
  - 3.把数据请求回来后,获取数据赋值给tableData,有了数据后,按照要求构建列表el-table
- ==最终效果图如下==: 
    [![pAWj7Cj.png](https://s21.ax1x.com/2024/11/21/pAWj7Cj.png)](https://imgse.com/i/pAWj7Cj)
- ==代码重点解析:==
  - ==**1.后端的2个模型构建:**==
  - ==1.1 公司数据模型==
  - CompanyRouter.js(==记得app挂载,复用度极高,没有删除功能==)
    ```
        var express = require('express');
        var CompanyRouter = express.Router();
        var CompanyController = require("../controllers/CompanyController.js")

        // 获取数据的 get
        CompanyRouter.get("/adminapi/companys",CompanyController.getList)

        // 添加用户的,数据发送方式和getList不同,这是post请求
        CompanyRouter.post("/adminapi/companys",CompanyController.addList)
        // 动态路由,:id是占位符,无论占位符输入什么都可以访问到/adminapi/users/
        CompanyRouter.put("/adminapi/companys/:id",CompanyController.updateList)


        module.exports = CompanyRouter // 记得app.js中注册
    ```
  - CompanyController.js(==更新数据函数有2个参数,id和请求体==)
    ``` 
        const CompanyService = require("../service/CompanyService")

        module.exports ={
            // 2个系统参数,接受前端的请求req合返回给前端的数据res,再向sevice发起一波请求,这是异步
            // 1.获取数据
            async getList(req,res){
                var result = await CompanyService.getList()
                res.send(result) // 把请求的数据传回给前端
            },
            // 2.添加数据
            async addList(req,res){
                var result = await CompanyService.addList(req.body)
                res.send(result) // 把请求的数据传回给前端
            },
            // 3.更新数据
            async updateList(req,res){
                var result = await CompanyService.updateList(req.params.id,req.body) // 传递path中的id信息和请求体
                res.send(result) // 把请求的数据传回给前端
            },
        }
    ```
  - CompanyService.js
    ```
        const CompanyModel = require("../model/CompanyModel")

        module.exports = {
            // 下面均为mongodb数据库操作

            getList() {
                return CompanyModel.find()
            },

            async addList(data) {
                // 处理重复文件的逻辑: 更新操作,无论有没有,直接更新,有的话即使重复名字也只是覆盖,没有的话就创建
                // data是公司数据,是一个数组,有多个数据,所以要遍历
                for (let i of data) {
                    await CompanyModel.findOneAndUpdate({
                        title: i.title, // 根据查询名字
                    }, {
                        $set: i // 查到,更新
                    }, {
                        upsert: true, // 查不到,插入
                    })
                }
                return []
            },

            async updateList(id,data){
                return CompanyModel.findByIdAndUpdate(id,data) // 根据id找到对应数据,更新数据为data
            }
        }
    ```
    - ==保留了查重机制,不允许重复添加一个excel文件的数据,其中改变的是,这次数据的添加是一个对象数组,我们从excle文件获取了一组的班级名字,在查重以及添加操作中,应遍历数组,一项一项地单个加进去==
    - CompanyModel.js(==改变了Schema的标准==)
    ```
        const mongoose = require("mongoose")
        const Schema = mongoose.Schema

        const CompanyType = {
            "title": String, // 公司名字
            "interview": String // 面试题
        }
        // company ---> companies
        const CompanyModel = mongoose.model("company",new Schema(CompanyType))

        module.exports = CompanyModel
    ```
    - 1.2==学生数据的模型==
    - CompanyStudentRouter.js(==记得app.js中注册,只有存post和取get==)
        ```
            var express = require('express');
            var CompanyStudentRouter = express.Router();
            var CompanyStudentController = require("../controllers/CompanyStudentController.js")

            // 获取数据的 get
            CompanyStudentRouter.get("/adminapi/companystudents",CompanyStudentController.getList)

            // 添加用户的,数据发送方式和getList不同,这是post请求
            CompanyStudentRouter.post("/adminapi/companystudents",CompanyStudentController.addList)
            // 动态路由,:id是占位符,无论占位符输入什么都可以访问到/adminapi/users/
            // StudentRouter.put("/adminapi/companys/:id",StudentController.updateList)

            module.exports = CompanyStudentRouter // 记得app.js中注册
        ```
    - CompanyStudentController.js(==没有新东西==)
        ```
            const CompanyStudentService = require("../service/CompanyStudentService")

            module.exports ={
                // 2个系统参数,接受前端的请求req合返回给前端的数据res,再向sevice发起一波请求,这是异步
                async getList(req,res){
                    var result = await CompanyStudentService.getList()
                    res.send(result) // 把请求的数据传回给前端
                },
                async addList(req,res){
                    var result = await CompanyStudentService.addList(req.body)
                    res.send(result) // 把请求的数据传回给前端
                }
            }
        ```
    - CompanyStudentService.js
        ```
            const CompanyStudentModel = require("../model/CompanyStudentModel")

            module.exports = {
                // 下面均为mongodb数据库操作

                getList() {
                    return CompanyStudentModel.find()
                },

                async addList(data) {
                    // 处理重复文件的逻辑: 更新操作,无论有没有,直接更新,有的话即使重复名字也只是覆盖,没有的话就创建
                    
                    for (let i of data) {
                        await CompanyStudentModel.findOneAndUpdate({
                            studentname: i.studentname, 
                            company: i.company
                        }, {
                            $set: i // 查到,更新
                        }, {
                            upsert: true, // 查不到,插入
                        })
                    }
                    return []
                },
            }
        ```
        - ==对就业学生的数据进行查重,遍历数据,一个一个查,查重标准:当学生名字和公司名字都一样时,认为这是个重复数据==
        - 注意: 这里的数据样本很少,所以不用很严谨,常规操作应当录入更多的信息防止重复,比如学号,毕业院校,公司id等
    - CompanyStudentModel.js
        ``` 
            const mongoose = require("mongoose")
            const Schema = mongoose.Schema

            const CompanyStudentType = {
                "company": String, // 公司名字
                "employ_date": String, // 雇佣日期
                "salary": String, // 薪资
                "studentname": String // 学生姓名 
            }
            // companystudent ---> companystudents
            const CompanyStudentModel = mongoose.model("companystudent",new Schema(CompanyStudentType))

            module.exports = CompanyStudentModel    
        ```
    - ==**学生数据的录入技巧**: 属性与excel每列的标题名一样,这样方便录入数据,即从excel提取出数据后,可以直接录入数据库对应的同名属性中==
- 最终效果图(==下面分别为学生就业数据库和公司名数据库==)
  [![pAWf6aV.png](https://s21.ax1x.com/2024/11/21/pAWf6aV.png)](https://imgse.com/i/pAWf6aV)
  [![pAWfyV0.png](https://s21.ax1x.com/2024/11/21/pAWfyV0.png)](https://imgse.com/i/pAWfyV0)
- ==2.构建el-table列表==
  - 2.1 搜素功能, search + includes() + 计算属性computedTableData
  - 2.2 常规列表, tem自定义,一列公司名,一列双按钮
  - 2.3 **==重点: 2个按钮的功能实现,一个是更新面试题,涉及新组件,一个是预览面试题==**
  - ==2.3.1更新面试题的实现==
  - 面试功能: 点击更新题库按钮,弹出dialog,内部的内容是一个新组件---==富文本编辑器==
  - 效果图: [![pAWvfzR.png](https://s21.ax1x.com/2024/11/21/pAWvfzR.png)](https://imgse.com/i/pAWvfzR)
  - 新组件介绍及使用: 
    - 在npmjs中,搜索wangeditor组件(开源 Web 富文本编辑器，开箱即用，配置简单。支持 JS Vue React)
    - 需要npm下载,当前有4和5两个版本,推荐5,都用一下
    - v5版本更好地适配了多个框架,例如vue,react,在文档中有模板(基于Vue React),我们直接使用提供的模板
  - v4版本:(==v4 下载: npm i wangeditor --save==)
  - Editor4.vue(==简单看看==)
    ```
        <template>
            <div id="div1"></div>
        </template>

        <script setup>
            // v4 下载: npm i wangeditor --save
            import { onMounted } from 'vue';
            import E from 'wangeditor'

            // 等待dom节点挂载完毕后方可初始化,所以要在onMounted中初始化new
            onMounted(() => {
                const editor = new E( document.getElementById('div1') )
                editor.create()
                // 文本编辑器的初始化
                editor.txt.html("<p>hello kerwin!</p>")
                // 监听文本编辑器内的内容变化,最后输出html代码字段(String类型),将来存入CompanyModel的interview属性
                editor.config.onchange = (newhtml)=>{
                    console.log(newhtml)
                }
            })
        </script>
    ```
    - ==**v5版本(推荐)**==
    - v5 下载2个组件,本体组件和适配vue的附加组件
      - npm install @wangeditor/editor --save 
      - npm install @wangeditor/editor-for-vue@next --save
    - 代码示例(==文档中有模板,复制过来,注意: 模板中不是"script + setup" ,我们改为setup模式==)
    ```
    <template>
        <div style="border: 1px solid #ccc">
            <!-- :editor="editorRef": 编辑器示例,注意,在Editor组件创建完毕后再初始化赋值,在其@onCreated="handleCreated"的处理函数内 -->
            <!--  :mode="mode": 编辑器模式 -->
            <Toolbar style="border-bottom: 1px solid #ccc" :editor="editorRef" :defaultConfig="toolbarConfig"
                :mode="mode" />
            <!-- v-model="valueHtml" 双向绑定的编辑器内容,可通过赋值实现初始化 -->
            <!-- @onChange: 在编辑区内容改变时自动调用; @onBlur: 失去焦点时才触发,更加'懒惰' -->
            <!-- @onCreated="handleCreated": 创建Editor组件时调用这个函数 -->
            <Editor style="height: 500px; overflow-y: hidden;" v-model="valueHtml" :defaultConfig="editorConfig"
                :mode="mode" @onCreated="handleCreated" @onChange="handleChange" />
        </div>
    </template>

    <script setup>
        import '@wangeditor/editor/dist/css/style.css' // 引入 css

        import { onBeforeUnmount, ref, shallowRef } from 'vue'
        import { Editor, Toolbar } from '@wangeditor/editor-for-vue'

        // 编辑器实例，必须用 shallowRef,浅层ref,只能绑定简单数据类型,或者复杂数据类型的最外层数据; 而ref可以递归遍历到复杂数据的深层结构
        const editorRef = shallowRef()

        // 获取父传子,内容是上次提交dialog后,编辑区的内容
        const props = defineProps(["content"])

        // 内容 HTML 双向绑定到Editor的内容 可以初始化内容
        const valueHtml = ref("")

        // 子传父事件获取
        const emit = defineEmits(["event"])
        const toolbarConfig = {}
        const editorConfig = { placeholder: '请输入内容...' }
        // 模式mode
        const mode = "default" // 默认模式,还有简单模式'simple' 

        // 编辑器Editor创建时,触发此函数
        const handleCreated = (editor) => {
            console.log("create")
            editorRef.value = editor // 记录 editor 实例，重要！
            // 每次打开更新题库重新初始化编辑组件Editor时,都对编辑区的内容(valueHtml.value)进行1次初始化,防止刷新丢失上次的内容
            // 这里有个坑: 需要等待editor实例创建后再对里面双向绑定属性valueHtml赋值,而这个函数handleCreated执行时间在onMounted后面,所以直接写在实例创建好代码的下面,保证安全
            valueHtml.value = props.content // 获取父信息
        }

        // 编辑区内容改变触发事件函数 onBlur类型
        // 这里有坑,我们使用onChange,这个函数更新数据的速度比dialog点击确认的handleUpdateConfirm更快,可以实时更新数据后再发送到后端
        const handleChange = () => {
            // console.log(valueHtml.value)
            emit("event", valueHtml.value) // 子传父
        }

        // 组件销毁时，也及时销毁编辑器
        onBeforeUnmount(() => {
            console.log("destory")
            const editor = editorRef.value
            if (editor == null) return
            editor.destroy()
        })
        </script>
    ```
    - 1.编辑器的tem由两部分组成,分别是Toolbar和Editor,分别负责工具栏和编辑区域
    - ==Toolbar中的属性:==
      - editor="editorRef": 编辑器示例,注意,在Editor组件创建完毕后再初始化赋值,在其@onCreated="handleCreated"的处理函数内
      - :mode="mode": 编辑器模式
    - ==Editor中的属性:== 
      - v-model="valueHtml" 双向绑定的编辑器内容,可通过赋值实现初始化
      - @onChange: 在编辑区内容改变时自动调用; @onBlur: 失去焦点时才触发,更加'懒惰' (==这里有坑,两个的函数的触发时间不同,后面讲==)
      - @onCreated="handleCreated": 创建Editor组件时调用这个函数
    - ==2.编辑器监听输入,@onChange="handleChange"==
    valueHtml双向绑定了输入的内容,通过监听,触发函数内部的子传父,把编辑器的输入内容发送给父组件,父组件在把这些题库数据发送给这个公司的数据库(interview部分),存储题库数据
    - ==重点代码截取==
        ```
            // 子传父(子组件)
            const handleChange = () => {
                // console.log(valueHtml.value)
                emit("event", valueHtml.value) // 子传父
            }
        -------------------------------------------------
            // 父接受子信息(父组件),@event="handleUpdateEditorEvent
            <Editor @event="handleUpdateEditorEvent" :content="currentItem['interview']" v-if="dialogUpdateVisible"></Editor>
        ```
    - ==@event="handleUpdateEditorEvent==
        ```
        const handleUpdateEditorEvent = (data) => {
            // 把当前点击的数据interview属性值改为编辑区的内容
            // currentItem是点击此数据时获取的scoped.row
            currentItem.value["interview"] = data 
        }
        ```
    [![pAWLlHe.png](https://s21.ax1x.com/2024/11/21/pAWLlHe.png)](https://imgse.com/i/pAWLlHe)
    - 子传父后,父组件临时存储信息,接下来处理'确认'按钮,即dialog的确认按钮,通过这个函数,我们向数据库提交函数(==**坑来了**==)
        ```
            // dialog,更新确认按钮函数
            const handleUpdateConfirm = async () => {
                // 当点击确定提交按钮时,提交编辑区的信息给后端,路径中传递了_id,用于确定是更新的哪个公司的题库
                await axios.put(`/adminapi/companys/${currentItem.value._id}`, currentItem.value)

                dialogUpdateVisible.value = false
                // 这里没使用 await getList(),是因为子传父已经在handleUpdateEditorEvent函数内部把编辑区内容(currentItem.value["interview"])更新了,这里相当于优化的代码,减少了1次后端请求
                // 之前不这么做的原因是数据太多了麻烦,这里就一个数据data
            }
        ```
    - ==坑: 这里的currentItem.value时我们向后端发送的请求体,内部是编辑区内容,但是如果我们的在Editor组件内使用的监听函数是onBlur,那么你会发现,这个数据为空,==**原因是,onBlur监听内容触发子传父的速度慢于提交axios的速度,导致还没给currentItem.value赋值编辑内容,就把空数据发送出去了**==
    - ==解决:== 使用onChange,这个函数更新数据的速度比dialog点击确认的handleUpdateConfirm更快,可以实时更新数据后再发送到后端
        > 阶段总结: 这一套流程为,我们点更新题库按钮,弹出dialog框,内部是文本编辑器,当我们在文本编辑器中输入内容时,通过onChange监听函数和双向绑定的属性valueHtml,通过子传父把数据发送给父组件,点击dialog的确认按钮时,触发父组件的handleUpdateConfirm函数,把子信息发axios给后端,保存在公司数据库的interview属性中
    - ==父传子的必要性 :content="currentItem['interview']==
    - 把当前对象的interview属性值再传回去,防止页面刷新后,丢失编辑区的信息,如果没有就是undefined 
        ```
            <Editor @event="handleUpdateEditorEvent" :content="currentItem['interview']" v-if="dialogUpdateVisible"></Editor>

            --------子接受父信息-----------------------
            // 子组件 js
            // 获取父传子,内容是上次提交dialog后,编辑区的内容
            const props = defineProps(["content"])

            // 编辑器Editor创建时,触发此函数
            const handleCreated = (editor) => {
                console.log("create")
                editorRef.value = editor // 记录 editor 实例，重要！
                // 每次打开更新题库重新初始化编辑组件Editor时,都对编辑区的内容(valueHtml.value)进行1次初始化,防止刷新丢失上次的内容
                valueHtml.value = props.content // 获取父信息
            }
        ```
    - ==这里有个坑: 需要等待editor实例创建后再对里面双向绑定属性valueHtml赋值,而这个函数handleCreated执行时间在onMounted后面,所以直接写在实例创建好代码的下面,保证安全==
    > 我们通过获取此公司的后端数据库中的interview题库部分的数据,实现了编辑区的内容保存,不会因为页面刷新而丢失上次的编辑内容
    - ==**大坑:(完成上述子父互传后)**==
    - ==现象==: 当我们编辑好一个公司的题库内容时,再更新其他公司的题库,会发现所有公司的题库编辑内容都一样
    - ==原因==: 因为我们对编辑器内容的赋值是在组件内的@onCreated函数中执行的,这个函数只有在组件Editor重新创建时才会执行,而我们打开不同公司的题库,只会在父传子的:content中发生了点变化,组件只会执行更新生命周期,不会重新走创建流程,所以也就不执行@onCreated函数,也就不会重新把新的父信息赋值给编辑区内容valueHtml,从始至终我们一直在用一个编辑器,他没有被销毁,导致之后我们更新数据就只会把内容的数据双向绑定到valueHtml属性上,然后大家(所有的公司)共用一个编辑器,所以内容都一样,也都同步更新
    - ==解决(之前用过)==: 使用v-if (v-if="dialogUpdateVisible"),每次都重新创建,每次也都重新执行@onCreated,每次也都重新赋值,而后端早就记录了上次编辑的内容了,所以即使editor组件销毁了,内容也不会因此丢失!
    ``` 
        <Editor @event="handleUpdateEditorEvent" :content="currentItem['interview']" v-if="dialogUpdateVisible"></Editor>
    ```
    > 总结: 至此所有关于更新题库的内容完成,每个公司都有自己独立的interview记录自己的题库,通过子父互传,实现了编辑器内容与数据库的互通有无,最后通过创建/销毁编辑器的办法,独立各个文本编辑器的内容
- ==3.预览题库的功能: 很简单了==
    ```
        // el-column-item内
        <el-button round type="primary" @click="handlePreview(scope.row)">面试题</el-button>

        <!-- 预览对话框(点击面试题按钮弹出) -->
        <el-dialog v-model="dialogPreviewVisible" title="预览题库" width="80%">
            <!-- 把内容的以HTML格式显示出来,使用v-html显示(特别信任这个后端的数据), {{}}不行,为了防止脚本攻击,vue设置了阻拦 -->
            <!-- 新组件,卡片组件,样式更好看,shadow属性改为hover,鼠标移动上去后,显示阴影 -->
            <el-card shadow="hover">
                <div v-html="currentItem.interview"></div>
            </el-card>
        </el-dialog>

        // 预览面试题函数
        const handlePreview = (data) => {
            // console.log(data.interview) // 可以拿到当前对象的面试题内容
            currentItem.value = data // 记录当前对象
            dialogPreviewVisible.value = true
        }
    ```
    - 1.获取当前公司题库数据 interview
    - 2.弹出新的dialog,内部内容为编辑器内容,使用新组件el-card(美观)
    - 3.为了实现html样式,使用了v-html
### 公司大数据
- 页面样板图如下(CompanyData.vue),和学生大数据差不多,不过用了新的组件
    [![pAWjXrV.png](https://s21.ax1x.com/2024/11/21/pAWjXrV.png)](https://imgse.com/i/pAWjXrV)
- 大体布局tempalte:
  - 整体的三栏布局还是24栏布局组件layout/el-row,
  - 我们可以通过echarts完成这个页面的构建,但是太麻烦了,==所以使用了新组件DataV的改版DataV-Vue3(已收藏)==,前者框架作者多年未更新了,后者是社区有人写的完善版本,更适配vue3,不过这个网站常常崩溃404,可以结合DataV原网站的vue2部分继续使用,新作者为了切合原版,很多模板使用方式几乎完全一样
- ==三个板块都有内部组件进一步完成,我们先进行整体布局结构规划==
  ```
    <template>
        <div id="companydata">
            <!-- 24栏组件,三等分,间距20px -->
            <!-- 整体使用datav大屏组件 边框10,里面的三个部分,两侧都是边框11,中间使用的是边框8 -->
            <dv-border-box10>
                <el-row :gutter="20">
                    <el-col :span="8">
                        <dv-border-box11 title="最受欢迎的公司" :title-width="400" :animate="false">
                            <!-- 父传子: 传递入职公司学生的各项数据信息 -->
                            <!-- 设置class属性,目的是设置css样式,三个组件都共有这个class属性,这个class属性会透传到子组件,css样式也同理 -->
                            <!-- 设置好定位后的内容可以正常地显示在内容中心,而不是左上角 -->
                            <Welcompany :datalist="datalist" class="company_data"></Welcompany>
                        </dv-border-box11>
                    </el-col>
                    <el-col :span="8">
                        <!-- dur: 单次动画时长(秒) -->
                        <dv-border-box8 :dur="5">
                            <!-- 装饰7 -->
                            <dv-decoration7 style="width:100%;height:50px;">
                                <div style="font-size:20px; color: white;">最不差钱的公司</div>
                            </dv-decoration7>
                        </dv-border-box8>
                    </el-col>
                    <el-col :span="8">
                        <dv-border-box11 title="最近入职的公司" :title-width="400" :animate="false"> </dv-border-box11>
                    </el-col>
                </el-row>
            </dv-border-box10>
        </div>
    </template>

    <script setup>
        // npm install @kjgl77/datav-vue3 下载后,在main.js中挂载

        // 和学生大数据思路一样,三个部分的数据在这里统一获取,通过父传子提供给各个组件
        import axios from 'axios'
        import { onMounted, ref } from 'vue';
        // 导入三个部分的组件
        import Welcompany from '../../components/company/Welcompany.vue'

        const datalist = ref([])
        onMounted(() => {
            getList()
        })

        const getList = async () => {
            var { data } = await axios.get("/adminapi/companystudents") // 获取入职公司学生的各项数据信息
            datalist.value = data
        }
    </script>

    <style scoped lang="scss">
        #companydata {
            background: url('../../assets/bg.png') no-repeat center;
            background-size: 100% 100%;
            padding: 10px;
            height: 84vh;
            // 三个组件的内容区域的css设置
            .company_data {
                position: absolute;
                top: 80px;
                width: 100%;
                color: white;
                text-align: center;
            }
        }

        .el-row {
            height: 600px;
            padding: 30px;
        }
    </style>
  ```
  - ==dv-border-boxXX: 这就是新组件DataV-Vue3,我们选取的边框样式==
  - 24栏不再赘述,三等分后,加了边距20px,背景图等样式设置同理
  - DataV-Vue3组件的使用
    - 下载: `npm install @kjgl77/datav-vue3`
    - main.js挂载: (==至此src内所有的vue文件都可以用了==)
    ```
        // 可视化组件DateV-Vue3引入
        import DataVVue3 from '@kjgl77/datav-vue3'

        .....
        .use(DataVVue3) // 众多use中的一项
        ....
    ```
  - 最后还有对3栏内组件的class样式设置,主要是内容的居中,字体的颜色,通过透传进入组件内部影响css格式
### 公司大数据-WelCompany组件
- 最左侧的图例: components/company/Welcompany.vue
- ==使用了胶囊柱图,config接受数据,调整样式,**为了响应式数据,我们使用计算属性computedComfig来对config数据进行配置**==
    ```
    <template>
        <dv-capsule-chart :config="computedComfig" style="width:100%;height:400px; box-sizing: border-box; padding: 20px;" />
    </template>
    ```
  - :config是柱状图数据来源的关键,配置的参数格式如下
    ```
        const config = {
            data: [
                {
                name: '南阳',
                value: 167
                },
                {
                name: '周口',
                value: 123
                },
                {
                name: '漯河',
                value: 98
                },
                {
                name: '郑州',
                value: 75
                },
                {
                name: '西峡',
                value: 66
                },
            ],
            colors: ['#e062ae', '#fb7293', '#e690d1', '#32c5e9', '#96bfff'],
            unit: '万元',
        }
    ```
    > 其中data是柱状图的数值,name是X轴名字,value就是Y轴值,colors是颜色版,unit是单位显示
- 重点在于data数据的配置,配置要求为 name->公司名 value->就职学生人数
- 父传子信息: datalist 入职公司学生的各项数据信息
  ```
        <Welcompany :datalist="datalist" class="company_data"></Welcompany>

        js:
        const datalist = ref([])
        onMounted(() => {
            getList()
        })
        const getList = async () => {
            var { data } = await axios.get("/adminapi/companystudents") // 获取入职公司学生的各项数据信息
            datalist.value = data
        }
  ```
- 子组件: 接受数据,整理数据
  ```
    <script setup>
        import { computed } from 'vue';
        import _ from 'lodash' // 很好用的js库,内含各种算法,方法
        const props = defineProps(["datalist"])
        // 加工props数据,作为data的参数,风格应为: name->公司名;value->就职学生人数
        
        const computedComfig = computed(() => {
            // 在这里对数据二次加工成对应的格式
            let { datalist } = props
            // 使用lodash,分组方法,groupBy() 第一个参数是要分组的对象,第二个参数是依据什么进行分组(每一项的company属性),即按照公司把datalist进行分组
            // 注意: 第二个参数的item会自动检索datalist的每一项数据
            // console.log(_.groupBy(datalist, item => item.company)) 
            // 结果是对象,每个item由"属性(公司名):属性值(数组)"组成,其中数组内部是对象,每个对象是就职于本公司的学生信息
            let groupObj = _.groupBy(datalist, item => item.company)
            let configData = []
            for(let item in groupObj){
                configData.push({
                    name: item, // key 公司名
                    value: groupObj[item].length // groupObj[item]=value,学生人数就取长度length
            })
        }
        // 最后倒序排序(大到小),基于configData内部的value属性排序,截取前8个公司
        const data = configData.sort((item1,item2)=>item2.value - item1.value).slice(0,8)

        return {
            data, // 简写
            colors: ['#e062ae', '#fb7293', '#e690d1', '#32c5e9', '#96bfff'],
            unit: '人数',
        }
    })
    </script>
  ```
  - ==问题: 接受父传子的信息datalist打印值为空==
  - ==原因:== 我们数据获取是异步的(==datalist是通过getList异步axios请求的==),当组件构建完成时,异步数据还没请求过来,即使是onMounted也早于数据的异步获取
  - ==解决:== 使用计算属性,特性是随着数据的变化实时更新,所以即使一开始没有数据,只要后期数据请求过来了,计算属性会帮我们响应式地更新数据
  - lodash库: 很好用的js库,内含各种算法,方法,==之前我们用过_.groupBy功能==
  - 看注释即可,主要是把学生按照公司进行分组,然后进行排序(倒序),最后截取前8为作为显示数据,其中把对应的数据按照规定好的格式push进对象data
  - lodash操作并排序后的效果图:
  [![pAWL8Nd.png](https://s21.ax1x.com/2024/11/21/pAWL8Nd.png)](https://imgse.com/i/pAWL8Nd)
  [![pAWL3AH.png](https://s21.ax1x.com/2024/11/21/pAWL3AH.png)](https://imgse.com/i/pAWL3AH)
### 公司大数据-RichCompany
- 处理中间页面的数据: (新组件,排名轮播表(自动对数据排序))
  ```
    <template>
        <!-- 排名轮播表(自动对数据排序),css样式复制welcompany.vue -->
        <dv-scroll-ranking-board :config="computedConfig"
            style="width:100%;height:400px; box-sizing: border-box; padding: 20px;" />
    </template>

    <script setup>
    // 和welcompany一样
    import _ from 'lodash' // js算法库,数据分组使用
    import { computed } from 'vue'
    const props = defineProps(["datalist"])
    // 和welcompany差不多,且不用排序操作
    const computedConfig = computed(() => { // 响应式接受数据,不会受异步影响(datalist是异步获取的)
        let { datalist } = props // 解构父信息
        let groupObj = _.groupBy(datalist, item => item.company)
        // console.log(groupObj)
        let configData = []
        for (let item in groupObj) {
            configData.push({
                name: item,
                // 公司入职学生平均值 = 入职学生工资总合/入职学生人数 (注意,salary在后端是字符串格式,转为数字类型)
                value: groupObj[item].reduce((total, item) => total + Number(item.salary), 0) / groupObj[item].length
            })
        }
        // console.log(configData)
        
        // 这个组件可以自动排序,所以直接把数据放进去即可
        return {
            data: configData,
            color: 'rgb(29,193,245)', // 进度条颜色
            unit: "元"
        }
    })
  ``` 
  - 基本和左边的Welcompany.vue一样,都进行了相同数据的父传子和css样式设置
  - data数据的样板:
    ```
        // value: 记录本公司入职学生的工资平均值,做排序; name公司名
        // const config = {
        //     data: [
        //         {
        //             name: '周口',
        //             value: 55
        //         },
        //         {
        //             name: '南阳',
        //             value: 120
        //         },
        //         {
        //             name: '西峡',
        //             value: 78
        //         },
        //          ........
        //     ],
        //     color: 'rgb(29,193,245)', // 进度条颜色
        //     unit: "元"
        // }
    ```
  - 再同理通过lodash分组后,对每个公司的平均学生薪资进行计算,唯一要注意的是salary是字符串类型,所以提前转化为number其余都很简单
### 公司大数据-EntryCompany
- 最后一个组件,右边的信息,复用也很高,父传子数据和css样式复用
- 唯一区别的也是data的数据整理,这里的data数据格式要求是一个二维数组,使用之前用过的Object.entries() 把对象的key和value转化为对应的二维数组
  ```
    // 数据模板
    // const config = {
    //     header: ['学生', '公司'],
    //     data: [
    //         ['行1列1', '行1列2', '行1列3'],
    //         ['行2列1', '行2列2', '行2列3'],
    //         ['行3列1', '行3列2', '行3列3'],
    //         ['行4列1', '行4列2', '行4列3'],
    //         ['行5列1', '行5列2', '行5列3'],
    //         ['行6列1', '行6列2', '行6列3'],
    //         ['行7列1', '行7列2', '行7列3'],
    //         ['行8列1', '行8列2', '行8列3'],
    //         ['行9列1', '行9列2', '行9列3'],
    //         ['行10列1', '行10列2', '行10列3'],
    //     ],
    //     index: false, // index 显示行号 Boolean
    //     columnWidth: [50], // 列宽
    //     align: ['center'], // 列对齐方式
    //     // headerBGC 表头背景色	String
    //     // oddRowBGC 奇数行背景色 String
    //     // evenRowBGC 偶数行背景色 String
    //     headerBGC: 'rgba(0,0,0,0)', // 统一透明
    //     oddRowBGC: 'rgba(0,0,0,0)',
    //     evenRowBGC: 'rgba(0,0,0,0)',
    //     // carousel	轮播方式 String	'single'/'page'(一个一个滚动/一页一页滚动)	
    //     carousel: 'page',
    //     waitTime: 4000 // 等待时间(ms) Number
    // }
    </script>

  ```
- ==根据入职日期进行排序,日期越大,代表最近入职,就在上面,日期employ_date数据是字符串格式,无法进行比较,需要转化为时间戳,Date.parse(String) --> 转化为Number时间戳,根据这个排序即可,其余没有太大区别了==
- 记住英文:  Date 日期; Data 数据
- 代码:
  ```
    <template>
    <!-- datav-vue3 轮播图 -->
    <div demo-bg>
        <!-- 使用计算属性configData,复用前面两个组件的css样式 -->
        <dv-scroll-board :config="configData" style="width:100%;height:400px; box-sizing: border-box; padding: 20px;" />
    </div>
    </template>


    <script setup>
    import { computed } from 'vue';

    // 同理,计算属性处理出合适的数据结构
    const props = defineProps(["datalist"])
    const configData = computed(() => {
        let { datalist } = props
        // 根据入职日期进行排序,日期越大,代表最近入职,就在上面
        // 日期employ_date数据是字符串格式,无法进行比较,需要转化为时间戳
        // Date.parse(String) --> 转化为Number时间戳
        // 倒序排序 item2 - item1 (大到小)
        // 记住英文:  Date 日期; Data 数据
        let data = datalist.sort((item1, item2) => Date.parse(item2.employ_date) - Date.parse(item1.employ_date))
        // console.log(data)

        // data是二维数组的格式 使用之前用过的Object.entries() 把对象的key和value转化为对应的二维数组
        // 所以我们要构建合适的对象结构,然后利用这个方法转为对应的二维数组
        const configObj = {} // 组装合适的对象结构
        data.forEach(item=>{ // 遍历data数组的每一项学生就业信息
            // 对象的key(学生名) = 对象的value(公司名)
            configObj[item.studentname] = item.company 
        })
        console.log(Object.entries(configObj)) // 结构正确的二维数组

        return {
            header: ['学生', '公司'],
            data: Object.entries(configObj),
            index: true, // index 显示行号 Boolean
            columnWidth: [50], // 列宽
            align: ['center'], // 列对齐方式
            // headerBGC 表头背景色	String
            // oddRowBGC 奇数行背景色 String
            // evenRowBGC 偶数行背景色 String
            headerBGC: 'rgba(0,0,0,0)', // 统一透明
            oddRowBGC: 'rgba(0,0,0,0)',
            evenRowBGC: 'rgba(0,0,0,0)',
            // carousel	轮播方式 String	'single'/'page'(一个一个滚动/一页一页滚动)	
            carousel: 'page',
            waitTime: 4000 // 等待时间(ms) Number
        }
    })

  ```

### 系统授权token验证
- ==截至现在,我们项目的安全隐患问题很大,所有人都可以轻易访问我们的后端,随意插入数据等,**所以需要设置token去限制不合法的访问,保护我们的后端数据**==
- 解决: 在npmjs中直接搜索jsonwebtoken即可找到,是个密钥多功能组件,==简单地使用jsonwebtoken的部分功能,实现基础的token生成业务和校验业务==
- ==使用jsonwebtoken构建token的功能:==
  - **token的相关处理涉及后端,所以在后端的myappServer的终端中下载**: `npm install jsonwebtoken`
  - ==在myappServer创建util文件夹,创建JWT.js文件,用来封装jsonwebtoken的功能函数==,供其他组件使用
    - ==JWT.js==
    - 先简单的组件的token创建与检验的函数用法:
    ```
        // 1.引入
        const jsonwebtoken = require('jsonwebtoken')
        const secret = "kerwin" // 额外加密的数据,盐

        // 2.sign内置方法,生成token
        var token = jsonwebtoken.sign({
            data: 'foobar' // 要加密的数据
        }, secret, { expiresIn: '1000ms' }); // secret 额外加密; expiresIn保质期 1s
        console.log(token)

        // 3.verify内置方法,校验token
        // 解析需要密钥token和盐secret
        console.log(jsonwebtoken.verify(token,secret)) // 校验密钥token是否过期,立即校验,没过期,会解析出原来的数据
        // 延时2s
        setTimeout(()=>{
            // console.log(jsonwebtoken.verify(token,secret)) // TokenExpiredError: jwt expired 密钥过期错误
            // 为了不是编译器报错终端,使用try-catch捕捉
            try{
                console.log(jsonwebtoken.verify(token,secret))
            }catch(e){
                console.log("密钥过期了")
            }
        },2000)
    ```
    - ==简单介绍密钥创建方法sign和密钥校验方法verify,我们就用这两个方法去封装==
    - secret: 额外加密,称为'盐',==十分重要,如果有人偷取了你的token,没有盐,他也无法解析内部的数据,相当于一个保险==
    - nodejs打印密钥测试:
    [![pAfVEp6.png](https://s21.ax1x.com/2024/11/22/pAfVEp6.png)](https://imgse.com/i/pAfVEp6)
  - ==**正式封装JWT函数**==
  ```
    const jsonwebtoken = require('jsonwebtoken')
    const secret = "kerwin" // 额外加密的数据,盐

        // 封装一个JWT对象,内含生成token和校验token2个函数
        const JWT = {
            generate(value, expires) { // value: 要生成密钥的数据 expires: 保质期时间
                // 密钥secret已经在上面了,使用JWT的人不能知道这个密钥,这是双层保险,没有这个密钥,即使窃取了token,也无法解析
                return jsonwebtoken.sign(value, secret, { expiresIn: expires }) 
            },
            verfiy(token) { // token: 要检验的token
                try{
                    return jsonwebtoken.verify(token,secret) // 成功了返回解析内容
                }catch(e){
                    return false // 过期了返回false
                }
            }
        }

        module.exports = JWT
  ```
  - ==这里生成密钥时,盐是我们JWT函数提供的,也就是用户如果直接使用你的工具组件进行密钥生成,他是不知道盐具体是什么的,所以盗窃者同理,也不知道,所以只有正规途径使用JWT的解析函数verfiy才能解析信息==
- 使用JWT去生成token: 登录时,我们在后端设置过登录校验功能,在UserController.js内部,==思路: 在登陆时,校验好用户信息后,把用户的username和_id封装为密钥,保质期1天,并把密钥封装如请求头的Authorization中,(潜规则命名为Authorization,可以随意起,但不建议),登陆成功后,会有一个post请求的请求头中有Authorization属性,内部的值就是token==
  [![pAfVV1K.png](https://s21.ax1x.com/2024/11/22/pAfVV1K.png)](https://imgse.com/i/pAfVV1K)
  ```
    const JWT = require("../util/JWT") // 记得引入

    ........
    async login(req, res) {
        var result = await UserService.login(req.body)
        if (result.length > 0) {
            // 不要返回密码
            let { _id, username, role } = result[0]
            // 引入JWT使用其内部创建token的函数,把用户的_id和username封装,进行token加密
            const token = JWT.generate({
                _id, // 简写
                username
            },"1d") // 1d = 1day
            // 把token存在请求头中,潜规则命名为Authorization(可以随意起,但不建议)
            res.header("Authorization", token)
            res.send({
                ActionType: "OK",
                data: { _id, username, role }// 返回匹配的数据
            })
        } else {
            res.send({
                ActionType: "fail" // 没有数据
            })
        }
    },
  ```
  - 登录成功后众多的axios请求中,打印找到了这个设置过请求头的请求信息
    [![pAfV2B4.png](https://s21.ax1x.com/2024/11/22/pAfV2B4.png)](https://imgse.com/i/pAfV2B4)
### axios拦截器-intercept
- 前提摘要: 我们已经通过jsonwebtoken组件,在第一次登录的时候生成了依次token.接下来要保存到本地localStorage中,然后拦截axios请求,进行token判断
- ==npmjs搜索axios,在里面再搜索intercept,这是axios拦截器,我们在vue跳转axios请求时,需要这个方法的拦截,它会拦截所有的请求(get/post/put/delete.....),所以在myapp/util中创建axios.config.js文件,专门用来处理axios的拦截问题==
- axios拦截器模板 (==注意: 记得在main.js中导入这里的axios的拦截器==)
  ```
    main.js: 
    // 导入axios的拦截器组件,只需要导入
    import "./util/axios.config"
    -----------------------------------
    axios.config.js

    axios.interceptors.request.use(function (config) { // config就是请求头
        // 在发送axios请求前做点什么
        // console.log("请求发送之前")
        const token = localStorage.getItem("token")
        // 给请求头的Authorization赋值token,除了第一次登录还没有在本地存token,之后在登录状态下,进行所有axios请求,都可以在本地存储中获取到token
        config.headers.Authorization = `Bearer ${token}` // 潜规则这么命名

        return config;
    }, function (error) {
        // 请求失败了,拦截错误的信息,先走到这里操作点什么,再在控制台报错
        return Promise.reject(error);
    });

    // axios收到信息拦截器
    axios.interceptors.response.use(function (response) {
        // axios成功发送,并收到信息,在这里做点什么
        // console.log("请求成功,请求信息为",response)
        // 寻找axios请求的请求头内含有密钥的信息(注意: 密钥生成于login校验步骤,所以在登录的时候才能从众多的请求信息的请求头中获取到authorization)
        const {authorization} = response.headers
        // 如果能捕捉到密钥信息,就存储到本地的token属性中,每次存储保证了token的新鲜性
        authorization && localStorage.setItem("token",authorization)
        return response;
    }, function (error) {
        // axios请求失败,返回了报错信息,在这里做点什么
        const {status} = error.response // 获取错误信息状态码
        if(status === 401){ // 401代表token过期了
        localStorage.removeItem("token") // 移除本地存储的过期token
        window.location.href = "#/login" // 暴力跳转到登录页面
        }
        return Promise.reject(error);
    });
  ```
  - 两个拦截:(==所有的axios会先进入这个拦截器的回调函数进行处理,然后再走常规流程==)
    - axios.interceptors.request.use(function (config))
      - config就是请求头
      - ==在发送axios请求前做点什么==
      - function (error): 请求失败了,拦截错误的信息,先走到这里操作点什么,再在控制台报错
    -  axios.interceptors.response.use(function (response))
       -  response就是res,内部含请求信息
       -  ==axios成功发送,并收到信息,在这里做点什么==
       -  function (error):  axios请求失败,返回了报错信息,在这里做点什么
- 1.利用axios拦截器,把第一次登录的token存在本地
- 在axios.interceptors.response.use处理,截取
  ```
    axios.interceptors.response.use(function (response) {
    // 寻找axios请求的请求头内含有密钥的信息(注意: 密钥生成于login校验步骤,所以在登录的时候才能从众多的请求信息的请求头中获取到authorization)
    const {authorization} = response.headers
    // 如果能捕捉到密钥信息,就存储到本地的token属性中,每次存储保证了token的新鲜性
    authorization && localStorage.setItem("token",authorization)

    return response;
  }, ....)
  ```
  - 其中authorization变为小写了,我们当时设置大写,因为系统一些操作,变为小写,可以打印response测试
  [![pAfu0SI.png](https://s21.ax1x.com/2024/11/22/pAfu0SI.png)](https://imgse.com/i/pAfu0SI)
- 2,保存本地token后,在发送axios之前,我们给请求头Authorization设置好token,以后我们会用来检测用,即如果你axios请求没有相关token,不予访问
  ```
    axios.interceptors.request.use(function (config) { // config就是请求头
        // 在发送axios请求前做点什么
        // console.log("请求发送之前")
        const token = localStorage.getItem("token")
        // 给请求头的Authorization赋值token,除了第一次登录还没有在本地存token,之后在登录状态下,进行所有axios请求,都可以在本地存储中获取到token
        config.headers.Authorization = `Bearer ${token}` // 潜规则这么命名
        return config;
    }, function (error) {
        // 请求失败了,拦截错误的信息,先走到这里操作点什么,再在控制台报错
        return Promise.reject(error);
    });
  ```
> ==阶段总结:== 第一次登陆,我们封装token到请求头的Authorization中,然后借助拦截器的axios.interceptors.response.use,拦截axios请求,寻找含有token信息的axios请求,找到后存入本地,再通过axios.interceptors.request.use,在所有的axios发送前,给所有的请求头Authorization属性赋值上这个token
- 3.==验证axios请求是否有合格的token==
  - 之前我们所有的路由都设置好了,如果一个个的验证,从router文件夹中一个个添加验证程序会很累,所以直接在myappServer/app.js的所有路由挂载前进行拦截,这样做就不必单独对每个路由进行校验,这里不通过,后面的都白玩
  ```
        // JWT jsonwebtoken npmjs搜索,一个生成token的插件
        const JWT = require('./util/JWT')

        // 后端路由拦截,这里不通过,后面的所有use路由挂载都不会执行
        // 这样做就不必单独对每个路由进行校验,这里不通过,后面的都白玩
        app.use((req, res, next) => {
        // 不拦截这个路由,这个路由中有我们的登录校验功能,其中使用JWT生成token并存入本地
        // 登录的时候肯定还没有token,这里无条件放行,否则本地中将永远获取不到token
        if (req.url === '/adminapi/users/login') {
            next()
            return
        }

        const token = req.headers["authorization"]?.split(" ")[1] // 使用三目,请求头authorization有内容,就继续下一步,获取token值 'Bearer XXXXXX' 通过空格分割,然后取后面的[1],即token值,而[0]为'Bearer',如果没有,token就为undefined
        if (token) { // 有token
            var payload = JWT.verfiy(token) // 校验token过没过期
            // console.log("校验结果",payload)
            if (payload) { // 成功,获取我们的解析内容,内含_id和username的值
            // 重新生成一个新的token: 这里的token保质期只有5s是为了测试使用
            // 测试效果是: 我们必须连续操作网站,一旦闲置5s后,在操作网站,就会被踢出重新去登录
            const newToken = JWT.generate({ 
                _id: payload._id,
                username: payload.username
            }, "1d") // 1d = 1day
            res.header("Authorization", newToken) // 重新设置res的请求头密钥,在这之后,我们在请求数据走axios收到信息拦截器,他会通过response获取res的值,再从里面获取请求头内部的新token
            next() // 记得放行
            } else { // token过期
            // 发送状态码401,并向前端发送错误的信息send({.....})
            // 再去axios.config.js拦截器中,处理下axios请求失败情况下的操作
            res.status(401).send({ errorCode: -1, errorInfo: "token过期" })
            }
        } else{
            // 有人直接通过网站访问数据,所以他的请求头中是没有authorization(密钥的),根据三目运算,此时token为undefined,走else代码区
            res.status(401).send({ errorCode: -2, errorInfo: "未授权登录" })
        }
        })

        // 默认提供了2个路由, /和/user,用于测试端口服务器是否打开
        app.use('/', indexRouter);   // http://localhost:3000
        app.use('/users', usersRouter); // http://localhost:3000/users
        // 注册,这个主路由默认/,要访问的话就寻找其子路由http://localhost:3000 + /adminapi/rights
        app.use(RightRouter)
        app.use(RoleRouter)
        app.use(UserRouter)
        app.use(TagRouter)
        app.use(ClassRouter)
        app.use(StudentRouter)
        app.use(CompanyRouter)
        app.use(CompanyStudentRouter)
  ```
- ==1.在所有的挂载use前面,保证了统筹拦截,只要这里不过关,后面的路由无法挂载,自然就无法访问==
- 2.不拦截'/adminapi/users/login',这个路由中有我们的登录校验功能,其中使用JWT生成token并存入本地,登录的时候肯定还没有token,这里无条件放行,否则本地中将永远获取不到token
- 3.重新生成token的原因: 
  - 我们在登录一个网站后,会获得一个token,假设token保质期1h,那么如果我们只在登陆时设置一个1h保质期的token,那么用户必须每隔一小时重新登陆一次,即使用户在使用这个网站,当到达1h后,会被强制退出访问,这是不合理的,我们要实现效果是,只要用户在使用网站,我们就不能让token过期
  - ==解决==: 在使用网站进行操作时,会发送许多的axios,拦截后,检查密钥是否过期,如果没有过期,那么重新生成一个新的密钥,这相当于把密钥的保质期重置了,只要这个新密钥的保质期够长,比如1h,那么只有当用户1h不操作网页时,才会被踢出;如果中间用户又操作了网站,那么重新计时1h,也就是用户闲置网站太久才会被踢出重新登陆,只要用户没有闲置网站太久,一直有操作,就会一直更新出新的token,就不会出现前面的问题
  - ==操作==: 使用三目,请求头authorization有内容,就继续下一步,获取token值 'Bearer XXXXXX' 通过空格分割,然后取后面的[1],即token值,而[0]为'Bearer',如果没有,token就为undefined
  - 如果token有效,就进一步解析它,生成payload,如果payload有数据,那就再利用JWT重新封装为新token,此时保质期重置
  - 1.==如果token没有为undefined==,判定此访问内部没有密钥,是非法访问,返回401处理结果,打印相关信息,典型为有人直接通过网站访问数据,所以他的请求头中是没有authorization(密钥的),根据三目运算,此时token为undefined,走else代码区
  [![pAfuaYd.png](https://s21.ax1x.com/2024/11/22/pAfuaYd.png)](https://imgse.com/i/pAfuaYd)
  - 2.==如果payload为空,说明token过期,解析不出数据,返回401信息==
  - 2.1 同时这里要处理axios访问失败的处理,上面当token解析不出数据时,会直接报错,因为代码走不通了,下面的use路由挂载全部失效,会报路由500错误(即没有这个路由),==再回到axios.config.js中,处理axios请求失败的函数==
  ```
        // axios收到信息拦截器
        axios.interceptors.response.use(function (response) {
            ......
        }, function (error) {
            // axios请求失败,返回了报错信息,在这里做点什么
            const {status} = error.response // 获取错误信息状态码
            if(status === 401){ // 401代表token过期了
            localStorage.removeItem("token") // 移除本地存储的过期token
            window.location.href = "#/login" // 暴力跳转到登录页面
            }
            return Promise.reject(error);
        });
  ```
  - 操作为: 删除本地token,前置跳转到登陆页面,让用户重新登录
- ==至此完结,通过检查用户的访问中有没有token来提高安全性==
  - 重点: jsonwebtoken新组件 axios拦截器的使用intercapt 实时更新token保质期等
### loading与nprogress
- 这两个组件是优化网页的,loading是在数据加载时,显示缓冲圈,nprogress是在加载时在页面上方显示进度条
- loading elenment提供的组件
- axios.config.js
  ```
    import { ElLoading } from 'element-plus'
    let loadingInstance = null // 定义变量(不能是const,一会要赋新值),一会用于加载loading效果

    axios.interceptors.request.use(function (config) { // config就是请求头
    // 在发送axios请求前做点什么
    // console.log("请求发送之前")

    // 所有的axios请求发送之前,调用的全屏Loading  
    loadingInstance = ElLoading.service({ fullscreen: true })

    .....

    return config;
  }, function (error) {
    // 请求失败了,拦截错误的信息,先走到这里操作点什么,再在控制台报错
    loadingInstance.close() // close 方法来关闭它
    return Promise.reject(error);
  });

    // axios收到信息拦截器
    axios.interceptors.response.use(function (response) {
        // axios成功发送,并收到信息,在这里做点什么
        // console.log("请求成功,请求信息为",response)

        // 当axios请求成功后,先把全屏的loading的效果关闭掉
        loadingInstance.close() // close 方法来关闭它
       .....
    }, function (error) {
        // axios请求失败,返回了报错信息,在这里做点什么
        loadingInstance.close() // 请求失败了也要关闭缓冲条, close 方法来关闭它
        ......
    });

  ```
  - 看文档,引入定义,然后使用,在axios发送前拦截并全屏启动loading,==axios请求无论成功和失败,都清除loading,否则他会一直显示loading==
  - 注意: 比如在学生大数据页面Home
  - 涉及多个请求axios情况,会多次返回调用loading,如果axios不强调先后顺序,可以promise.all(),等待所有axios结束再进行下一步
    ```
    onMounted(async () => {
        // 函数本身的异步不会影响外面的同步执行,所以外面也要异步
        // 一个页面多个axios,会闪现多次loading组件的显示,每一次axios的'请求与成功'拦截,都会执行一次loading的显示(/util/axios.config.js)
        // 为了loading组件显示更好,把axios所有的请求综合到一起
        // promise的all方法,内部是数组,当数组内的所有请求都完成时,才算完成进入下一步
        // all方法没有先后顺序要求,所以这三个await不能有强制的先后顺序
        // 测试: 在调试窗口把网络调速度整到3g即可
        await Promise.all([getStudentList(),getClassList(),getTagList()])

        // await getStudentList()
        // await getClassList()
        // await getTagList()

        isCreated.value = true
    })
    ```
   - npmjs nprogress 新组件
   - 下载: npm i nprogress
   - ==进度条显示在路由加载前,所以把代码写在路由的加载拦截器,加载完后记得删除==
   - router/index.js
        ```
        // 模块化使用nprogress,文档没有说明
        import NProgress from 'nprogress'
        import 'nprogress/nprogress.css' // 需要引入css

        // 路由拦截(路由守卫): 对所有(beforeEach)没有登录授权的用户统一跳转到Login页面
        router.beforeEach((to,from,next)=>{
            // 开始进度条
            NProgress.start();
            .....
        })

        // 路由跳转之后
        router.afterEach(()=>{
            // 结束进度条
            NProgress.done()
        })
        ```
    > 注意: 官方文档中,没告诉模块化使用方式,一定记住处理引入本体外,还要引入其css相关文件
### 编译部署 
- 编译部署就是把vue的代码打包为浏览器认可的html+css+js的代码,代码构造`npm run build`
- ==现在前端vue/vite使用代理服务器向后端nodejs服务器发送数据,交互数据,一般情况下(数据量较大),前端和后端应该各自配置一个服务器,vite属于开发者服务器,是用于开发的不是正常的服务器; 但在数据量较小的情况下,可以把前端的代码打包为静态资源,放入myappService的静态文件夹public内部,这样只需要开启后端服务器(local 3000)即可运行项目,而且没有跨域问题==

## 升级战略
### 升级战略-学生登录
- ==新增学生身份==,学生身份与教师和admin都不同,有自己独特的路由解构,并且有些路由的操作被限制,比如学生可以看自己的评分,但不能给自己打分等
- 介绍: ==学生拥有的路由有"学生大数据,公司大数据,公司大数据,学生列表(评分页面),**新增个人中心路由**==
- ==1.新建center.vue,并配置相关信息==
  - 1.1==创建vue文件==views/center/ + center.vue , 还是文件夹分类,内部最基本的tem+div解构先测试用
  - 1.2==配置vue的路由path==
    - router/config.js (==路由集中存放地==)
        ```
        const routes = [
            {
                path:"/index",
                name:"Home",
                component:Home
            },
            {
                path:"/center",
                name:"Center",
                component:Center // 记得引入vue
            },
            {
                path:"/user-manage/list",
                name:"UserList",
                component:UserList
            },
            ...
        ]
        ```
  - 2.==新增登录路由 Login.vue==
    - 原先只有讲师和admin两个角色时,登录校验等操作均请求adminapi/users/login路径,依据user表;==现在在students表的基础上,新增一个登录功能==
    - 2.1 首先给students表添加密码属性password
      - StudentService.js 添加学生信息addList,给所有人设置默认密码123
      - StudentModel.js 设置schema的StudentType + "password":String
      - ==**至此,学生表所有人都新增属性"password": 123**==
    - 2.2 给studentRuter.js添加登录的路由,负责学生登录校验,新增函数login(==一条龙写了==)
        ```
        // 学生登录校验
        StudentRouter.post("/adminapi/students/login",StudentController.login)

        --------------------------------

        StudentController.js
        async login(req, res) { // 登录校验
            // console.log(req.body)
            var result = await StudentService.login(req.body)
            if (result.length > 0) {
                // 不要返回密码
                let { _id, studentname,introduction,avatarUrl,gender } = result[0]
                // 引入JWT使用其内部创建token的函数,把用户的_id和username封装,进行token加密
                const token = JWT.generate({
                    _id, // 简写
                    username: studentname
                }, "1d") // 1d = 1day
                // 把token存在请求头中,潜规则命名为Authorization(可以随意起,但不建议)
                res.header("Authorization", token)
                res.send({
                    ActionType: "OK",
                    data: {
                        _id, username: studentname, // 统一格式
                        introduction,avatarUrl,gender, // 额外返回信息,用于center页面的介绍,头像地址,性别信息
                        "role": { // 学生登录的role信息是固定的,不可更改
                            "roleName": "学生",
                            "roleType": 3,
                            "rights": [
                                // 学生可以登录的路由
                                "/index",
                                "/center",
                                "/interview-manage",
                                "/interview-manage/companylist",
                                "/interview-manage/companydata",
                                "/student-manage",
                                "/student-manage/studentlist",
                            ]
                        }
                    }// 返回匹配的数据
                })
            } else {
                res.status(400).send({
                    ActionType: "fail" // 没有数据
                })
            }
        },
        ```
    - StudentController.js中登录校验功能基本复制的usercController.js的内容,逻辑相同的token校验和更新等操作,唯一区别的是,==学生数据的返回(res.send)自己需要的路由,都是固定写好的,如上代码==
    - 注意: 统一一下格式,原来通过持久化pinia存在本地的数据是username,所以赋值统一一下,==我们SideMenu显示就是根据本地存储的信息显示的==,如下图:
    [![pAhKCdS.png](https://s21.ax1x.com/2024/11/24/pAhKCdS.png)](https://imgse.com/i/pAhKCdS)
    - ==通过返回相同的信息res.send,特别是学生的role(**关乎路由以及SideMenu和内容的创建**),构建出学生身份独有的身份页面==
    [![pAhKFiQ.png](https://s21.ax1x.com/2024/11/24/pAhKFiQ.png)](https://imgse.com/i/pAhKFiQ)
  - ==2.2.1没有显示个人中心center页面==
  - 其实这个接口已经有了,但是不显示,看components/SideMenu.vue
    ```
    

    onMounted(async () => {
        var res = await axios.get("/adminapi/rights") // 取public的lib的json文件,获取数据

        rightsList.value = res.data // 获取信息赋值给空数组rightsList
    })

    const checkAuth = (path) => {
        return rights.includes(path)
    }
    ```
  - ==其实SideMenu在添加侧边栏时,依据的rights表进行校验,所以我们需要**在数据库rights表中手动添加center的路由信息**==
  [![pAhKes0.png](https://s21.ax1x.com/2024/11/24/pAhKes0.png)](https://imgse.com/i/pAhKes0)
  - ==2.2.4 try+catch捕获优化==
  - 如果promise.any两个都失败了,说明输入的用户不存在,这是需要捕获失败行为,返回message失败消息,不用catch就会直接报错,下面的逻辑是,先校验form表单,校验失败直接返回message失败信息,如果成功,再进一步校验用户存在与否,如果用户不存在,catch捕获,同理返回message失败信息,只有用户存在,才登录成功进入系统
    ```
    // 校验form表单成功情况下
         if (valid) {
            // 把用户的关联替换为真正的数据请求,发送校验请求
            // loginForm是username和password(用户登录的数据)
            try {
                const res = await Promise.any([axios.post("/adminapi/users/login", loginForm), axios.post("/adminapi/students/login", {
                    studentname: loginForm.username, // students表和user表不同,所以整理下数据传递过去
                    password: loginForm.password
                })])

                console.log(res.data)

                let { ActionType, data } = res.data
                if (ActionType === 'OK') {
                    console.log("data: ", data)
                    changeUser(data) // 把用户信息存起来
                    console.log("登录成功")
                    router.push("/")
                } else {
                    // Message组件,弹出错误信息,ElMessage需要引入
                    ElMessage.error('用户不存在')
                }

            } catch (e) { // 当Promise.any都失败时,res就没有信息,执行let { ActionType, data } = res.data,会报错,从undefined中获取信息,所以走catch
                ElMessage.error('用户不存在')
            }

        } else { // 校验表单失败
            console.log('error submit!', fields)
        }
    ```
  - ==2.2.5侧边栏有班级列表,学生不应看到班级列表(学生管理的二级路由)==
  - ==原因: SideMenu,其构建二级菜单的过程中没有校验==,一级菜单有校验,所以教师和admin2个角色的一级菜单显示才有区别
    ```
         <!-- 需要校验二级菜单是否存在,v-for和v-if不能同时在一起 -->
        <template v-for="item in data.children" :key="item.path">
            <el-menu-item :index="item.path" v-if="checkAuth(item.path)">
                <el-icon>
                    <component :is="mapIcon[item.icon]"></component>
                </el-icon>
                {{ item.title }}
            </el-menu-item>
        </template>

    ----------------------js----------------
    const route = useRoute() // 应用于el-menu主菜单标签的default-active属性,使用route.fullPath获取当前路由的路径,就搜索栏的那行
    const { user: { role: { rights } } } = useUserStore() // 获取useUserStore的user的值(用户信息),再在role/rights中找到path集合信息
    // 权限函数,rights为此用户拥有访问权限的路径,path会把所有路径都拿过来一个一个地测试一遍,通过的为true,失败的为false
    const checkAuth = (path) => {
        return rights.includes(path)
    }
    ```
    - 注意: v-for和v-if不能同时在一起,所以加了template
  - ==2.3Login.vue配置学生登录== 
    - Promise.all() 都成功才会有结果
    - Promise.race() 看谁获取的快就是谁,有风险,如果登陆学生账户,但是users的请求更快于students,就会走请求失败.catch,出现误导
    - ==Promise.any() 任意一个成功的,就走.then,两个都失败才走.catch,成功的那个最终会返回出res==
        ```
            const res = await Promise.any([axios.post("/adminapi/users/login", loginForm), axios.post("/adminapi/students/login", {
                    studentname: loginForm.username, // students表和user表不同,所以整理下数据传递过去
                    password: loginForm.password
            })])

            console.log(res.data)
        ```
    - ==注意: 在传递数据,用户名和密码的时候,在students表中,学生的名字属性是studentname,不是username,以后会有多个涉及这里的细节==
    - **这一步操作是,在登录时同时校验2条路径,那个走的同去那个,同时传递用户名和密码2个信息给后端,校验是否有这个用户**
  - ==2.4路由配置问题== 
    - promise.any内的两个axios其实无论返回谁都是成功的,status 200 OK, 为何? ==如果不改变状态码,虽然我们心里认为这是个失败返回(ActionType: "fail"),但是电脑还是会接收到一个对象,它会认为这是成功(因为有res返回值,它才不管你里面写的什么,代表什么意思,有返回就是OK),状态码200,**所以我们必须定义400,请求失败的状态码,同时返回失败的信息**==
  - 解决: 在UserController.js和StudentsController.js表中,对于失败的返回值额外加一个状态码400的设置,规定了这个返回数据属于失败的(==代码上面有一个示例==),这样2个axios肯定有一个会失败,成功的那个会赋值给res,然后进行登录校验等操作,然后进入系统页面

- ==**总结**==: 
  - Login.vue中,promise.any配置2条axios请求登录的路径,一个学生,一个老师和admin,同时使用try-catch捕获2条都出错的欣慰
  - 学生axios的请求: 需要新建login校验专属路由和处理方法(仿照教师和admin登录校验即可),同时改变students表的结构,新增password类型,addlist给所有学生添加默认密码123
  - SideMenu部分: 页面的center添加和学生页面显示: res返回学生role(rights),生成学生的路由导航页面,center添加进rights表,这是导航添加的依据
### 升级战略-学生权限
- 对一些页面进行限制,例如: 学生页面虽然有学生列表界面,但是只能看自己的评分,并且不能给自己评分,只能教师角色和admin角色才有权限.
- ==更改公司列表conpanyList.vue==
- ==学生不具备更新题库,上传excle文件的功能,仅保留搜索公司和查看面试题的2个功能==
  - 删除更新题库按钮
    ```
    tem:
     <el-table-column align="left" label="操作">
            <template #default="scope">
                <!-- 调整下高度,调整某一个的行高,这一行的行高都会跟着变化 -->
                <div style="display: flex; align-items: center; height: 55px;">
                    <el-button round type="primary" @click="handlePreview(scope.row)">面试题</el-button>
                    <el-button round type="warning" @click="handleUpdate(scope.row)" v-if="roleType!=3" >更新题库</el-button>
                </div>
            </template>
    </el-table-column>

    JS:
        import { useUserStore } from '../../store/useUserStore';

        // 无法响应时的更新
        const {user:{role:{roleType}}} = useUserStore() // 获取用户的信息roleType
        
    ```
    - useUserStore是pinia的函数,在store中useUserStore.js中定义的函数,返回此登录者的信息,通过结构获取,roleName=3代表的学生身份,在更新按钮设置v-if判断是否是学生,是的话不创建
    - ==在center页面构建时,我们会认识到具备响应性的重要性==
`


- ==更改学生列表StudentList.vue== 
- ==学生只能看自己的评分,并且不能给自己评分,不具备搜索学生姓名的功能==
  - 禁用搜索学生功能 + 自动搜索自己的信息 + 禁止学生评分
    ```
    tem:
    <el-table-column>
            <!-- table自定义表头 -->
            <template #header>
                <!-- 双向绑定的数据记录你输入的值,搜索框有禁用限制,学生不可用 -->
                <el-input v-model="search" size="small" placeholder="请输入学生的名字" :disabled="roleType===3" />
            </template>
            <template #default="scope">
                {{ scope.row.studentname }}
            </template>
    </el-table-column>

    <el-alert type="info" show-icon>
            请为<b style=" font-size: 20px;">{{ currentItem.studentname }}</b>同学评分
        </el-alert>
        <el-divider />
        <!-- 评分板 -->
        <div v-for="item in tagData" :key="item._id">
            <div class="rate-item">
                <div>{{ item.title }}</div>
                <!-- 评分: 监听handleRateEvent,获取点击的值($event默认数据) -->
                <!-- XXX可清空: clearable 双击相同分数清空为0 -->
                 <!-- rate打分表禁用 -->
                <el-rate :colors="colors" allow-half @change="handleRateEvent($event, item.title)"
                    :model-value="getItemRate(item.title)" clearable :disabled="roleType===3" />
            </div>
            <el-divider></el-divider>
        </div>
    </el-alert?


    js: 
    // 同理使用stroe
    import { useUserStore } from '../../store/useUserStore';

    // 无法响应时的更新
    const {user:{role:{roleType},username}} = useUserStore() // 获取用户的信息roleType

    onMounted(() => {
        if(roleType===3){ // 搜索框禁用后,需要自动赋值本学生名字搜索出本学生的信息
            search.value = username
        }
        getList()
        getClassList()
        getTags()
    })
    ```
    - 1.使用disabled+roleName身份判断,禁用搜索功能
    - 2.在生命周期中,自动给搜索双向绑定的值赋值本用户,自动搜索
    - 3.el-rate的disabled+roleName身份判断,禁止学生评分
### 升级战略-Center布局 + 接口处理
- center页面最终效果图,个人信息的修改,==看着图片和布局提示,理解代码==
    [![pAhasUA.png](https://s21.ax1x.com/2024/11/25/pAhasUA.png)](https://imgse.com/i/pAhasUA)
- ==布局概括:== 
  - 页面布局 24栏 左右比例1:2,使用el-card美化显示,有阴影
    ```
        <el-row :gutter="10" class="elRow">
        <el-col :span="8">
            <!-- el-card立体感更强的装饰组件 -->
            <el-card style="text-align: center;">
                <!-- 头像组件avatar -->
                <!-- 头像的图片是计算属性circleUrl -->
                <el-avatar :size="100" :src="circleUrl" />
                <!-- 这样写有响应性 -->
                <h3>{{ store.user.username }}</h3>
                <h5>{{ roleName }}</h5>
            </el-card>
        </el-col>
        <el-col :span="16">
            <el-card>
                form表单...
            </el-card>
        </el-col>
    ```
  - 顶栏使用新组件---page header
    ```
    <!-- 新组件page header,下面代码非模板,简单的使用了一些API直接生成的页面 -->
    <!-- icon	Page Header 的图标 Icon 组件 -->
    <!-- title	Page Header 的主标题，默认是 Back (内置 a11y)	 -->
    <!-- content Page Header 的内容 -->
    <el-page-header icon="" content="个人中心" title="学生学业质量管理系统"></el-page-header>

    ```
  - 左侧使用avatar组件,构建头像框,下面响应式学生名字; 头像值初始化默认值
  - 登录的表单tem复制Login.vue的form表单代码,改造一下
    - 性别: 下拉列表 el-select + el-option,==label是下拉列表显示的名字,value的值会被传递给userForm.gender,传向后端,下拉列表时动态组件的,配置的options的值==
    - select的数据代码:
      ```
      const options = [
          {
              label: "保密",
              value: 0
          },
          {
              label: "男",
              value: 1
          },
          {
              label: "女",
              value: 2
          }
      ]
      ```
  - 个人介绍: el-input , text文本框,设置type=textarea类型即可
  - ==上传头像el-upload(新组件): 附带一些css样式一并复制过来(**组件的css样式要加 :deep()**); 记得配置相关的rules==
  - 表单代码:
    ```
        <el-form ref="userFormRef" style="max-width: 600px" :model="userForm" :rules="rules" label-width="auto" class="demo-ruleForm" status-icon>
            <el-form-item label="用户名" prop="username">
                <el-input v-model="userForm.username" />
            </el-form-item>
            <el-form-item label="密码" prop="password">
                <el-input v-model="userForm.password" type="password" />
            </el-form-item>
            <el-form-item label="性别" prop="gender">
                <!-- 下拉列表,双向绑定选中的性别 -->
                <el-select style="width:100%;" v-model="userForm.gender">
                    <!-- label是下拉列表显示的名字,value的值会被传递给userForm.gender,传向后端 -->
                    <el-option v-for="item in options" :key="item.label" :label="item.label"
                        :value="item.value"></el-option>
                </el-select>
            </el-form-item>
            <el-form-item label="简介" prop="introduction">
                <!-- text文本框,type=textarea类型 -->
                <el-input v-model="userForm.introduction" type="textarea" />
            </el-form-item>
            <el-form-item label="头像" prop="avatar">
                <!-- upload的上传/用户头像: :auto-upload 禁止自动上传,需要由更新按钮提交控制上传; :show-file-list 不显示上传列表,和上传excle文件下的列表一样  -->
                <!-- companyList中我们就用过这个上传组件,on-change响应式监听上传图片的情况 -->

                <!-- 封装下面的代码 -->
                <el-upload class="avatar-uploader" :show-file-list="false" :auto-upload="false"
                    :on-change="handleChange">
                <!-- v-if-else: 如果有userForm.avatar(头像,双向绑定的头像属性,可以获取后端存储的数据),正常显示上传的头像图片,如果没有走else,默认显示一个图标Plus(引入) -->
                <!-- :src可以接受图片的二进制格式,再显示图片 -->
                <img v-if="userForm.avatar" :src="avatarComputed" class="avatar" />
                    <el-icon v-else class="avatar-uploader-icon">
                        <Plus /> // 没有上传任何图片,默认显示Plus组件(这是element的icon图标,记得引入)
                    </el-icon>
                </el-upload>

                <!-- 组件封装 components/center/... -->
                <kerwin-upload :avatar="userForm.avatar" @change="handleChange"></kerwin-upload>
            </el-form-item>


            <el-form-item class="el-form-item-button">
                <el-button type="primary" @click="submitForm(userFormRef)">
                    更新
                </el-button>
            </el-form-item>
        </el-form>

    ```  
- 定义好表单的双向绑定userForm,通过ref获取form节点,把userForm相关属性默认双向绑定到form表单里(除了密码),==后期提交把数据存入数据库,再次打开即可自动初始化==
  ```
    const userFormRef = ref() // ref传统用法: 获取el-form的实例对象(ref="loginFormRef") 
    const userForm = reactive({
        username,
        password: "",
        gender,// 下拉列表
        introduction, // 自我介绍
        avatar: avatarUrl, // 头像地址
        file: null // 给后端的文件对象信息(默认没有)
    })
  ```
- ==表单的上传图片新组件upload的使用==
- 上传图片需要显示图片,还要把图片的信息发送到后端,==依靠on-change监听上传图片的行为,**通过默认参数可以获取图片的信息,和上传excel文件获取信息一样**==
  ```
    // 文件上传---监听上传图片 
    // 接受子信息file(组件KerwinUpload) ---> evt
    const handleChange = (evt) => {
        console.log(evt.raw)
        userForm.file = evt.raw // 存储文件对象信息
        userForm.avatar = URL.createObjectURL(evt.raw) // 显示图片,把图片转化为二进制格式显示
    }
  ```
- 获取的默认信息打印如下
  [![pAhcsLq.jpg](https://s21.ax1x.com/2024/11/25/pAhcsLq.jpg)](https://imgse.com/i/pAhcsLq)
- ==文件图片上传的知识:==
  - 在 JavaScript 中，img标签的src属性通常是指向一个 URL（可以是相对路径或者绝对路径），用于加载图像资源。它本身不直接支持二进制参数码这种说法。
  - 不过，==有一种间接的方式可以将类似二进制数据（实际上是经过编码的二进制数据）用于src属性==，那就是 Data URLs。Data URLs 允许将小文件（如图片）直接嵌入到文档中，格式为`data:[<mediatype>][;base64],<data>`。
  - ==这种方式可以用于加载一些小的图像（因为 Data URLs 会使 HTML 文件变大），或者在没有方便的服务器端存储和提供图像的情况下，临时展示图像,比如表单上传图片==。
  - ==URL.createObjectURL()是一个 JavaScript 方法，它用于创建一个 DOMString，这个 DOMString 包含一个表示对象（通常是File或Blob对象）的 URL。这个 URL 是一个临时的 URL，它的生命周期和创建它的文档相关联。
  - ==**使用URL.createObjectURL()方法将这个文件对象转换为一个 URL，并将其赋值给新创建的img元素的src属性。这样，就可以在页面上显示用户选择的文件（假设是图片）的预览。所以userForm.avatar获取了转化好的图片值,通过表单双向绑定给upload组件的src属性,临时显示上传的图片**==
  - 注意: ==当你使用URL.createObjectURL()创建了一个对象 URL 后，这个 URL 会占用内存资源==。**为了避免内存泄漏，当你不再需要这个 URL 时，应该调用URL.revokeObjectURL()方法来释放内存**。
  > 注意: 为了代码可运行,我们没有更改任何代码,也没有添加清除缓存的机制
- 表单提交验证:
    ```
        // 提交表单按钮函数
        const submitForm = () => {
            // 
            userFormRef.value.validate(async (valid) => {
                if (valid) { // 校验通过
                    console.log(userForm) 
                  
                    // 提交userForm信息(复杂表单,含文件上传)给后端
                    // 当你需要处理文件上传或者构建更复杂的表单数据结构，包括同时包含文件和文本数据的表单时,new FormData()就非常有用
                    // 可以使用FormData对象来构建请求体数据,将表单的信息一个个存入FormData对象里面,作为axios向后端发送的数据载体,同时搭配请求头multipart/form-data
                    const params = new FormData()
                    for (let i in userForm) { // 获取userForm表单对象的每一个key
                        if (i !== "avatar") { 
                        // 我们不需要avatar的值(avatarUrl)进后端,这个没有用,avatarUrl作用只是作为特殊的二进制编码,给表单提交图片的src赋值,显示临时图片效果,重新选择图片或者跳转页面过后,会被销毁
                        // 真正需要传给后端的是图片信息存储的属性file,将来初始化页面的时候(用户已经修改过个人信息,并将头像图片传递给后端存储在数据库了),从数据库获取file数据,在通过URL.createObjectURL()转化即可又获取到特殊的二进制编码,也就是之前avatarUrl的数据,所以存储avatar属于多此一举,file信息内隐含它的信息,只需要通过转化即可获得
                            params.append(i, userForm[i]) // 添加userForm表单的数据,格式类似于 "username" : "张三" (key,value)
                        }
                    }

                    // 最后的upload是用于区分和其他post请求的path格式
                    const res = await axios(`/adminapi/students/${_id}/upload`,params,{
                        headers: {
                            "Content-Type": "multipart/form-data" // 针对file属性值为文件数据信息
                        }
                    })
                    console.log(res);

                    // 改变pinia store
                    changeUser({
                        ...store.user, // 旧信息
                        username: res.data.studentname, // 注意: 老信息是username,而新的信息(可以从数据库students表中看)对应的是studentname,所以同步一下
                        ...res.data, // 新信息
                    })

                }
            })
        }

    ```
    - ==1.validate方法用于触发表单验证,防止有人直接点击更新不填信息(在Login.vue表单提交验证时用过1次)==,validate方法接受一个回调函数作为参数。这个回调函数会在验证过程完成后被调用，并且会传入一个valid参数。如果valid为true，表示所有字段都通过了验证；如果valid为false，表示至少有一个字段验证失败
    - ==2.表单的提交验证==
    - ==2.1请求头配置Content-Type==
       - Content-Type 请求头指定了请求体的媒体类型。常见的值包括：

       - ==application/json: 表示请求体是 JSON 格式的数据。==

       - ==application/x-www-form-urlencoded: 表示请求体采用 URL 编码的表单数据。==

       - ==**multipart/form-data: 表示请求体包含文件上传的数据。 <------ 选择这个请求头**==
   - ==我们上传图片,文件时转化数据已经不再是简单的form表单提交了,所以需要额外设置请求头类型,默认情况是前2个==
  > 
   - ==2.2表单form的数据整理==
   - 当你需要处理文件上传或者构建更复杂的表单数据结构，包括同时包含文件和文本数据的表单时,==需要借助new FormData()去转化form表单信息==
   - ==可以使用FormData对象来构建请求体数据,将表单的信息一个个存入FormData对象里面(`.append()`方法),作为axios向后端发送的数据载体,同时搭配请求头multipart/form-data==
- ==**后端的工作(针对表单提交)**==
- ==1.基础的数据库格式和返回的数据数量==
- 提交表单给后端,需要在StudentModel.js中添加新的数据类型供数据库存储,同时在StudentController.js中返回这些新的数据,通过axios返回提供给res
  ```
  ------------Model-------------------
    const StudentType = {
        "studentname" : String, // excel表格里名字栏就是这么写的,这样命名方便后端数据的处理(特指有中文也要用key-value映射给变成英文)
        "class" : {type:Schema.Types.ObjectId,ref:"class"}, // 学生的班级,链接class的ObjectId
        "score": Object, // 学生的成绩是对象格式,tag标签那里的所有标签就是科目,到时候会有对应的成绩
        "password": String, // 密码类型 
        "avatarUrl": String, //头像值
        "gender": Number, // 0 1 2(对应保密 男 女)
        "introduction": String // 介绍
    }

    ---------Controller--------------------
    res.send({
        ActionType: "OK",
        data: {
            _id, username: studentname, // 统一格式
            introduction,avatarUrl,gender, // 额外返回信息,用于center页面的介绍,头像地址,性别信息
            "role": { // 学生登录的role信息是固定的,不可更改
                "roleName": "学生",
                "roleType": 3,
                "rights": [
                    // 学生可以登录的路由
                    "/index",
                    "/center",
                    "/interview-manage",
                    "/interview-manage/companylist",
                    "/interview-manage/companydata",
                    "/student-manage",
                    "/student-manage/studentlist",
                ]
            }
        }// 返回匹配的数据
    })
  ```
- ==2.构建接受表单数据的路由和函数==
- StudentRouter.js
  ```
    // 接受文件需要新的插件multer(隶属express的小插件)
    const multer  = require('multer') // npm i multer下载
    const upload = multer({ dest: 'public/uploads/' }) // dest存放文件的地址,我们直接存到静态文件夹内部即可

    // 动态路由,:id是占位符,无论占位符输入什么都可以访问到/adminapi/users/
    // 需要添加中间件(multer的用法), single()内的参数是存放文件的属性名字file
    StudentRouter.post("/adminapi/students/:id/upload",upload.single("file"),StudentController.upload)
  ```
  - Multer 是一个用于处理multipart/form - data类型表单数据的中间件，主要用于在 Node.js 的 Express 框架中方便地处理文件上传。
  - ==使用前记得先下载`npm i multer`和引入==
  - 上面的multer代码指定了将来文件的存储地址dest,以及使用了multer中间件,==upload.single('file')表示这个路由处理函数期望**接收一个名为file的文件。Multer 会从请求中提取这个文件，并将其存储在req.file对象中**。文件信息包括文件名、文件大小、文件类型等。==
  - ==**我们在前端axios发送表单数据时,正是file属性存储了文件的信息,所以这里的single内的参数就写file,同时记住这个文件信息会存入req.file中**,这与其他常规信息(用户名,密码,性别等非文件类简单字符串信息)存储位置不同,这些简单信息还是存在req.body中==
- StudentController.js
  ```
    async upload(req, res) { // 更新个人中心函数
        // console.log(req.file,req.body) // multer使用方法,打印一下配置的file文件信息req.file和其他请求体信息req.body
        // res.send([])
        // 传参, 占位符的id , 图片文件的信息(自成一体) , 其他信息(请求体)
        var result = await StudentService.upload(req.params.id, req.file, req.body)
        res.send(result) 
    },
  ```
  - 在这打印一下经过处理的req信息,==分别是req.file和req.body,在后端的myappServer终端中查看==,前者是经过multer处理后存储文件信息的,后者是正常存储表单简单内容
  - 上面的是req.file的打印,比如有文件的名字filename(系统自己起的名字)和path(我们规定dest后,文件存储的路径信息)
  - 下面的就是常规信息的打印,req.body
    [![pAhc6e0.jpg](https://s21.ax1x.com/2024/11/25/pAhc6e0.jpg)](https://imgse.com/i/pAhc6e0)
  - 随后把用户信息的id,头像信息req.file,常规信息req.body传给下一个service函数
> 
- StudentService.js(==获取用户信息的id,头像信息req.file,常规信息req.body并更新数据==)
    ```
    // 更新center页面的函数
        upload(id,file,body){
            if(file){ // 更新头像了,file不为null
                return StudentModel.findByIdAndUpdate(id,{
                    ...body,
                    studentname: body.username, // body内的名字和数据库名字不同,同步并覆盖一下
                    avatarUrl: `/uploads/${file.filename}` // 因为在静态文件夹,所以省略public,filename是multer对图片名字信息的重命名,这样我们前端src的本地地址也配置好了
                },{returnDocument: "after"}) // 额外属性: 获取更新后的信息
            }else{ // 没有更新头像,file为null,所以就不更新了
                return StudentModel.findByIdAndUpdate(id,{
                    ...body,
                    studentname: body.username, // body内的名字和数据库名字不同,同步并覆盖一下
                },{returnDocument: "after"}) // 额外属性: 获取更新后的信息
            }
        },
    ```
    - 注意: ==在students表中名字是studentname属性管理,而传递来的res.body中存储名字的属性名为username,统一为studentname再进入数据库==
    - ==存储avatarUrl的信息是本地地址,只能在自己电脑上玩玩==
    - returnDocument: "after": 额外属性: 获取更新后的信息,这样前端会获取更新后的一手数据
    - 最后学生数据库的内容存储了表单的信息,如下 
        [![pAhgRBt.jpg](https://s21.ax1x.com/2024/11/25/pAhgRBt.jpg)](https://imgse.com/i/pAhgRBt)
> 
- ==提交完表单,存储完学生数据进入数据库后,下一步在前端请求数据,如果用户在之前提交过个人信息,并提交存储在数据库内了,那么我们从数据库请求出数据直接初始化好个人中心==

- ==信息获取:获取用户的登录信息==
    - 我们通过useUserStore()获取的信息就是pinia持久化存在本地的数据,如下图(==这是admin的登录信息示例==): 
    [![pAhKCdS.png](https://s21.ax1x.com/2024/11/24/pAhKCdS.png)](https://imgse.com/i/pAhKCdS)

- 代码:(==然后动态配置即可(记住没有响应性,之后会讲如何改)==)
    ```
    js:
    import { useUserStore } from '../../store/useUserStore';
    const { user: { role: { roleName }, username, _id, gender, introduction, avatarUrl }, changeUser } = useUserStore()

    const userForm = reactive({
        username,
        password: "",
        gender,// 下拉列表
        introduction, // 自我介绍
        avatar: avatarUrl, // 头像地址
        file: null // 给后端的文件对象信息
    })
    ```
- 通过在本地存储中获取了足够的信息,然后存入双向绑定的表单数据userForm中,如果数据库有数据,那么就会获取,然后赋值给相关属性(==看好userForm内部赋值都是ES6简便写法(username,gender,introduce),其中密码不能初始化显示(保密),avartar属性名和数据库属性名不同,不能简写,file不会在前端页面显示==)
- 其中图片的显示avatar需要特殊处理:
- 为了动态显示上传头像的图片,使用计算属性去动态化显示(==响应性!!==)
  ```
    在tem中,circleUrl会赋值给upload组件的src属性的
  ------------------js------------------
    const circleUrl = computed(() => 
        userForm.avatar.include("blob") ? useForm.avatar : 'http://loacalhost:3000' + userForm.avatar
    )
  ```
    - ==前提: 我们每次上传更新数据库图片到后端,都要经过URL.createObjectURL()对图片文件的处理,然后存入表单的userForm双向绑定属性avatar中,其中经过这个方法处理后,会生成一个带有blob字段的地址文件,大体为'blob XXXXXXX'后面的XXX就是转化的文件信息等== 
    - 三目: 意为如果有blob字段,说明你刚上传了一个图片进入表单,那么就显示这个刚上传的图片,经过URL.createObjectURL()处理上传文件后转为特殊二进制赋值给表单useForm.avatar,直接用它即可
    - (==前提: 首先用户已经有个人中心数据了,排除第一次登录的情况==)如果没有blob字段,说明用户还没有上传图片,那么userForm.avatar的数据是数据库存储的,也是上次用户存的图片,==userForm.avatar获取的是数据库的avatarUrl的值,也就是存放图片的绝对地址,存储位置是后端服务器的静态文件夹,所以加好前缀(后端服务器地址)http://localhost:3000,拼接起来就是一个图片的正经地址,赋值给src即可显示存储在数据库内部的图片信息==
- 处理完avatar头像的动态更新后,用户的信息就可以从数据库获取学生个人中心的信息,从而实现初始化,显示上次用户保存的个人信息
> 
- ==注意: 这里箭头函数老犯错,计算属性这里==
  ```
    // func1和func2都是返回数字100,但是写法不同

    // 多行代码,加{},返回数据+return
    const func1 = ()=>{
        let a = 100
        return a
    }
    // 单行代码,可以省略{}和return
    const func2 = ()=> 100
  
  ```
- 处理bug: 如果我们不更新头像,点击更新,后端直接报错500,为何?
  - 因为我们的表单数据file属性默认null(初始化),如果我们不更新图片,那么axios像后端会传递一个file = null的文件,后端multer处理文件信息时,会把null存入req.file文件中,后续会报错的
- 修正: (==StudentService.js==)
  ```
    // 更新center页面的函数
    upload(id,file,body){
        if(file){ // 更新头像了,file不为null
            return StudentModel.findByIdAndUpdate(id,{
                ...body,
                studentname: body.username, // body内的名字和数据库名字不同,同步并覆盖一下
                avatarUrl: `/uploads/${file.filename}` // 因为在静态文件夹,所以省略public,filename是multer对图片名字信息的重命名,这样我们前端src的本地地址也配置好了
            },{returnDocument: "after"}) // 额外属性: 获取更新后的信息
        }else{ // 没有更新头像,file为null,所以就不更新了
            return StudentModel.findByIdAndUpdate(id,{
                ...body,
                studentname: body.username, // body内的名字和数据库名字不同,同步并覆盖一下
            },{returnDocument: "after"}) // 额外属性: 获取更新后的信息
        }
    },
  ```
  - 判断file是否为空,为空就不更新头像属性了,如果不为空,再更新进数据库,否则avatarUrl: \`uploads/${file.filename}\`,相当于从undefined中取值  
- ==完成更新bug调试后,提交表单更新后,获取到res数据,然后把res存在本地中(持久化pinia),使用userstore.js函数changeUser==
  ```
        const { user: { role: { roleName }, username, _id, gender, introduction, avatarUrl }, changeUser } = useUserStore()
        const store = useUserStore() // 具有响应性的用法,直接用于实时更新页面各处的信息,再写一遍

        const res = await Untilkerwinupload(`/adminapi/students/${_id}/upload`,userForm)
        console.log(res);
        // 改变pinia store
        changeUser({
            ...store.user, // 旧信息
            username: res.data.studentname, // 注意: 老信息是username,而新的信息(可以从数据库students表中看)对应的是studentname,所以同步一下
            ...res.data, // 新信息
        })

  ```
  > 注意: 对象res返回的信息是students表中的信息,而主页pinia存储要求的格式是username,统一一下
  - 重新创建一个store变量用于存储旧信息,res存储新信息,展开覆盖进去
  - 最终本地化存储的效果如下,学生的数据库信息经过pinia持久化存储到本地
  [![pAh4RBj.jpg](https://s21.ax1x.com/2024/11/25/pAh4RBj.jpg)](https://imgse.com/i/pAh4RBj)
> 
- ==最后一个问题,响应性更新页面的信息,比如左边的头像和姓名,顶栏的头像和姓名==
- 解决: 想要响应性更新,不能结构pinia本地化存储的信息,而是直接获取整个对象信息,然后通过.的方式,获取内部信息,这样具有响应性
- 个人中心center.vue左侧的响应式更新:
  ```
    <el-col :span="8">
            <!-- el-card立体感更强的装饰组件 -->
            <el-card style="text-align: center;">
                <!-- 头像组件avatar -->
                <!-- 头像的图片是计算属性circleUrl -->
                <el-avatar :size="100" :src="circleUrl" />
                <!-- 这样写有响应性 -->
                <h3>{{ store.user.username }}</h3>
                <h5>{{ roleName }}</h5>
            </el-card>
    </el-col>

    ------------js------------------
    const circleUrl = computed(() => 
        // createObjectURL,同理拼接下地址,显示图片即可
        store.user.avatarUrl ? 'http://localhost:3000' + store.user.avatarUrl : 'https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png'
    )
  ```
  - 头像的响应性也是计算属性,如果store.user.avatarUrl是undefined,说明还没有上传过图片,给后面的默认值(那个地址是element提供的默认头像地址); 如果上传过图片,会走前面,提取数据库图片信息,配置好本地路径,显示用户数据库内部存储的图片作为头像
- 同理顶部栏 components/mainbox/Topheader.vue
  ```
    tem:
    <div>
        <span style="line-height:40px; margin-right:20px;">欢迎{{store.user.username}}回来</span>
        <el-dropdown>
            <!-- CDN导入,简单的 -->
            <!-- <el-avatar :size="40" src='https://cube.elemecdn.com/9/c2/f0ee8a3c7c9638a54940382568c9dpng.png'/> -->
            <!-- 本地导入,vite工具导入图片有点麻烦 -->
            <el-avatar :size="40" :src="avatar"></el-avatar>
            <template #dropdown>
                <el-dropdown-menu>
                    <el-dropdown-item>身份:{{roleName}}</el-dropdown-item>
                    <el-dropdown-item @click="handleExit">退出</el-dropdown-item>
                </el-dropdown-menu>
            </template>
        </el-dropdown>
    </div>
    

    js:
    const store = useUserStore()
    // 本地图片vite的导入
    // const avatar = new URL('../../assets/userImg.png',import.meta.url).href
    const avatar = computed(() => 
        // 和center的头像一个处理方式,代码相同,下面是2个方法
        store.user.avatarUrl ? 'http://localhost:3000' + store.user.avatarUrl : 'https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png'
        // store.user.avatarUrl ? 'http://localhost:3000' + store.user.avatarUrl : new URL('../../assets/userImg.png',import.meta.url).href
    )
  ```
    - ==学生姓名响应性: {{store.user.username}}==
    - ==学生头像的响应性: src = avatar(来自计算属性)==

### 升级战略-Center封装
- 封装upload部分为组件components; 封装axios-post提交表单为工具类组件util
    > ==注意: 记得引入在center.vue中引入2个封装的组件==
- ==封装upload--> kerwinUpload==
    ```
     <kerwinUpload :avatar="userForm.avatar" @change="handleChange"></kerwinUpload>
    ```
  - ==父传子: 传递表单的avatar头像信息; 子传父change自定义事件== 
  - conponents/cneter/KerwinUpload.vue
    ```
    <template>
        <el-upload class="avatar-uploader" :show-file-list="false" :auto-upload="false" :on-change="handleChange">
            <img v-if="props.avatar" :src="avatarComputed" class="avatar" />
            <el-icon v-else class="avatar-uploader-icon">
                <Plus />
            </el-icon>
        </el-upload>
    </template>

    <script setup>
        import { Plus } from '@element-plus/icons-vue' // 引入新图标
        import { computed } from 'vue'
        // 接受父信息
        const props = defineProps(["avatar"])
        console.log(props.avatar) // 通过props.avatar可以获取传递过来的信息


        // 显示图片动态配置src属性的计算属性函数
        const avatarComputed = computed(() =>
            // blob是URL.createObjectURL(evt.raw)转化为一个带有blob字段的内容,如果有,说明经过了URL.createObjectURL处理,如果没有,说明是从后端返回过来的(上一次的),加好前缀地址
            props.avatar.includes("blob") ?
                props.avatar : 'http://localhost:3000' + props.avatar
        )

        const emit = defineEmits(["change"]) // 子传父
        // file是默认参数,是上传文件的信息,原来我们常写为 "evt.raw" 去获取关键信息
        const  handleChange = (file)=>{
            emit("change",file,avatar) // 子传父
        }
    </script>

    .....把css样式复制过来
    ```
  - 父传子: 接受信息-->props,同理剪切计算属性进来动态配置头像显示
  - 子传父: emit-->change(父自定义事件),传递默认参数file,即upload上传文件的信息
  - 父组件(change触发事件函数handlechange不用动),接受evt就是子传过来的file参数
    ```
    const handleChange = (evt) => {
        console.log(evt.raw)
        userForm.file = evt.raw
        userForm.avatar = URL.createObjectURL(evt.raw) // 把图片转化为二进制格式显示
    }
    ```
- 封装axios  center.vue
  ```
        const res = await Untilkerwinupload(`/adminapi/students/${_id}/upload`,userForm)
        console.log(res);
  ```  
- util/kerwinupload.js
  ```
        import axios from 'axios'

        function Untilkerwinupload(path,userForm) {
            
            const params = new FormData()
            for (let i in userForm) { // 获取userForm表单对象的每一个key
                if (i !== "avatar") {
                    params.append(i, userForm[i]) // 添加userForm表单的数据,格式类似于 "username" : "张三" (key,value)
                }
            }

            return axios.post(path,params, {
                headers: {
                    "Content-Type": "multipart/form-data" // 针对file属性值为文件数据信息
                }
            })
        }

        export default Untilkerwinupload
  ```
  - 在外部直接传入表单数据即可,组件内部可以转化好表单的类型 new FormData,并且配置好请求头发送axios